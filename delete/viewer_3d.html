<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>DXF 3D Viewer</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; }
    #renderCanvas { width:100%; height:100%; touch-action:none; }
  </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

async function createScene() {
  const scene = new BABYLON.Scene(engine);
  scene.clearColor = new BABYLON.Color4(0.95, 0.95, 0.95, 1);

  // 카메라 & 라이트
  const camera = new BABYLON.ArcRotateCamera(
    "cam",
    -Math.PI / 2,
    Math.PI / 3,
    20,
    new BABYLON.Vector3(0, 0, 0),
    scene
  );
  camera.attachControl(canvas, true);

  const light = new BABYLON.HemisphericLight(
    "light",
    new BABYLON.Vector3(0, 1, 0),
    scene
  );

  // JSON 로드
  const data = await fetch("Drawing1.json").then(r => r.json());
  const layers = data.layers;

  // 바운딩 박스 계산
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;

  function updateBounds(x, y) {
    if (x < minX) minX = x;
    if (x > maxX) maxX = x;
    if (y < minY) minY = y;
    if (y > maxY) maxY = y;
  }

  Object.keys(layers).forEach(layer => {
    layers[layer].forEach(e => {
      if (e.type === "LINE") {
        updateBounds(e.start[0], e.start[1]);
        updateBounds(e.end[0],   e.end[1]);
      } else if (e.type === "LWPOLYLINE") {
        e.points.forEach(p => updateBounds(p[0], p[1]));
      }
    });
  });

  const w = maxX - minX;
  const h = maxY - minY;
  const maxSize = Math.max(w, h);

  // mm → m 스케일만 적용 (0.001)
  const mmToM = 0.001;

  const cx = (minX + maxX) / 2;
  const cy = (minY + maxY) / 2;

  const root = new BABYLON.TransformNode("root", scene);

  function toWorld(x, y) {
    const nx = (x - cx) * mmToM;
    const nz = (y - cy) * mmToM;
    return new BABYLON.Vector3(nx, 0, nz);
  }

  Object.keys(layers).forEach(layer => {
    layers[layer].forEach(e => {
      if (e.type === "LINE") {
        const pts = [
          toWorld(e.start[0], e.start[1]),
          toWorld(e.end[0],   e.end[1]),
        ];
        const line = BABYLON.MeshBuilder.CreateLines("line", { points: pts }, scene);
        line.parent = root;
        line.color = new BABYLON.Color3(0, 0, 0);
      } else if (e.type === "LWPOLYLINE") {
        if (!e.points || e.points.length < 2) return;
        const pts = e.points.map(p => toWorld(p[0], p[1]));
        const line = BABYLON.MeshBuilder.CreateLines("poly", { points: pts }, scene);
        line.parent = root;
        line.color = new BABYLON.Color3(0, 0, 0);
      }
    });
  });

  // 도면 실제 크기(m)에 맞춰 카메라 거리 설정
  const maxSizeM = maxSize * mmToM;
  camera.target = root.position;
  camera.radius = maxSizeM * 1.5;  // 도면이 화면에 넉넉히 들어오도록

  return scene;
}

createScene().then(scene => {
  engine.runRenderLoop(() => scene.render());
});

window.addEventListener("resize", () => {
  engine.resize();
});
</script>
</body>
</html>
