<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>AR Phase 2.2 - Final Fixes</title>
    <!-- Babylon.js Library -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>

<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);

        // --- Global State ---
        let CAD_A1 = null;
        let CAD_A2 = null;
        let World_b1 = null;
        let World_b2 = null;

        // 앵커 목록 정의
        const anchorList = [
            { id: "b1", label: "B1 (Yellow)" },
            { id: "b2", label: "B2 (Green)" },
            // 나중에 { id: "b3", label: "B3 ..." } 이런 식으로 계속 추가 가능
        ];

        let currentAnchorId = "b1";   // 기본 선택

        // --- GUI Functions ---
        let ui_selectBtn, ui_status;
        let debugTextControl = null;

        function logToScreen(msg) {
            console.log(msg);
        }

        const createScene = async function () {
            const scene = new BABYLON.Scene(engine);
            const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
            camera.setTarget(BABYLON.Vector3.Zero());
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 1.0;

            // --- GUI Setup ---
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

            ui_status = new BABYLON.GUI.TextBlock();
            ui_status.text = "";
            ui_status.color = "yellow";
            ui_status.fontSize = 20;
            ui_status.textVerticalAlignment = 0; // TOP
            ui_status.paddingTop = "40px";
            ui_status.height = "100px";
            advancedTexture.addControl(ui_status);

            // --- B1/B2 선택 + '선택' 버튼 패널 ---
            const panel = new BABYLON.GUI.StackPanel();
            panel.width = "180px";         // 고정 픽셀
            panel.horizontalAlignment = 1; // RIGHT
            panel.verticalAlignment = 1;   // BOTTOM
            panel.paddingBottom = "20px";
            panel.paddingRight = "20px";
            advancedTexture.addControl(panel);

            // --- 앵커 선택용 목록 패널 ---
            const listRect = new BABYLON.GUI.Rectangle();
            listRect.width = "300px";          // 고정 픽셀로 확대
            listRect.height = "200px";         // 고정 픽셀로 확대
            listRect.thickness = 1;
            listRect.color = "white";
            listRect.background = "black";
            listRect.alpha = 0.7;
            listRect.cornerRadius = 10;
            listRect.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            listRect.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            listRect.paddingBottom = "20px";   // 20px 띄움
            advancedTexture.addControl(listRect);

            const listLabel = new BABYLON.GUI.TextBlock();
            listLabel.text = "Anchor 선택";
            listLabel.height = "24px";
            listLabel.color = "white";
            listLabel.textHorizontalAlignment = BABYLON.GUI.TextBlock.HORIZONTAL_ALIGNMENT_LEFT;
            listLabel.paddingLeft = "8px";
            listLabel.paddingTop = "4px";
            listRect.addControl(listLabel);

            // 스크롤 영역
            const scroll = new BABYLON.GUI.ScrollViewer();
            scroll.width = 1;
            scroll.height = "160px";           // 고정 높이
            scroll.top = "24px";
            scroll.barSize = 8;
            scroll.thickness = 0;
            listRect.addControl(scroll);

            const listPanel = new BABYLON.GUI.StackPanel();
            listPanel.isVertical = true;
            scroll.addControl(listPanel);

            // 목록 아이템 생성
            anchorList.forEach(anchor => {
                const btn = BABYLON.GUI.Button.CreateSimpleButton(`anchor_${anchor.id}`, anchor.label);
                btn.height = "50px";           // 버튼 높이 고정
                btn.color = "white";
                btn.fontSize = 20;             // 폰트 크기 고정
                btn.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                btn.textBlock.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                btn.paddingLeft = "8px";
                btn.background = (anchor.id === currentAnchorId) ? "gray" : "transparent";

                btn.onPointerUpObservable.add(() => {
                    currentAnchorId = anchor.id;

                    // 선택된 항목만 회색 배경으로 표시
                    anchorList.forEach(a => {
                        const b = advancedTexture.getControlByName(`anchor_${a.id}`);
                        if (b) b.background = (a.id === currentAnchorId) ? "gray" : "transparent";
                    });
                });

                listPanel.addControl(btn);
            });

            function createBtn(name, text, color, callback) {
                const button = BABYLON.GUI.Button.CreateSimpleButton(name, text);
                button.width = "100%";         // 패널 너비(180px)에 꽉 차게
                button.height = "80px";        // 높이 고정
                button.color = "white";
                button.fontSize = 24;          // 폰트 크기 고정
                button.background = color;
                button.paddingBottom = "5px";
                button.onPointerUpObservable.add(callback);
                return button;
            }

            ui_selectBtn = createBtn("btn_select", "선택", "gray", () => {
                // XR hit test가 아직 성공하지 않으면 그냥 리턴
                if (!isHit) {
                    ui_status.text = "바닥을 먼저 인식시켜 주세요.";
                    return;
                }

                const hitPos = reticleRoot.position.clone();

                if (currentAnchorId === "b1") {
                    if (World_b1) World_b1.dispose();

                    const s = BABYLON.MeshBuilder.CreateSphere(
                        "b1_sphere",
                        { diameter: 0.05 },
                        scene
                    );
                    s.position = hitPos;
                    s.material = new BABYLON.StandardMaterial("m1", scene);
                    s.material.diffuseColor = BABYLON.Color3.Yellow();
                    s.material.disableLighting = true;
                    s.material.emissiveColor = BABYLON.Color3.Yellow();
                    World_b1 = s;

                    logToScreen(
                        `World b1 Set: ${hitPos.x.toFixed(2)}, ${hitPos.y.toFixed(2)}, ${hitPos.z.toFixed(2)}`
                    );
                } else if (currentAnchorId === "b2") {
                    if (World_b2) World_b2.dispose();

                    const s = BABYLON.MeshBuilder.CreateSphere(
                        "b2_sphere",
                        { diameter: 0.05 },
                        scene
                    );
                    s.position = hitPos;
                    s.material = new BABYLON.StandardMaterial("m2", scene);
                    s.material.diffuseColor = BABYLON.Color3.Green();
                    s.material.disableLighting = true;
                    s.material.emissiveColor = BABYLON.Color3.Green();
                    World_b2 = s;

                    logToScreen(
                        `World b2 Set: ${hitPos.x.toFixed(2)}, ${hitPos.y.toFixed(2)}, ${hitPos.z.toFixed(2)}`
                    );
                }

                // 두 점 + CAD A1/A2까지 다 준비되면 정합 실행
                if (World_b1 && World_b2 && CAD_A1 && CAD_A2) {
                    performAlignment();
                }
            });

            panel.addControl(ui_selectBtn);


            // --- Load CAD Data ---
            let cadRoot = new BABYLON.TransformNode("CAD_Root", scene);
            cadRoot.setEnabled(false);

            try {
                logToScreen("Fetching Office_3.json...");
                const response = await fetch("Office_3.json?t=" + Date.now());
                if (!response.ok) throw new Error("Fetch Error: " + response.status);
                const cadData = await response.json();

                logToScreen("JSON Keys: " + Object.keys(cadData).join(", "));

                // DEEP PARSING for 'layers' structure
                let entities = [];

                // Case 1: Root is array
                if (Array.isArray(cadData)) {
                    entities = cadData;
                }
                // Case 2: Root has 'entities' or 'features'
                else if (cadData.entities) entities = cadData.entities;
                else if (cadData.features) entities = cadData.features;
                // Case 3: Root has 'layers' dictionary (Common in some converters)
                else if (cadData.layers) {
                    // Iterate all keys in 'layers'
                    // structure might be: { layers: { "0": [...], "A1": [...], ... } }
                    // OR: { layers: [ {name:"A1", entities:[...]}, ... ] }

                    if (Array.isArray(cadData.layers)) {
                        cadData.layers.forEach(l => {
                            if (l.entities) entities = entities.concat(l.entities);
                        });
                    } else {
                        // layers is Object
                        for (let layerName in cadData.layers) {
                            let layerContent = cadData.layers[layerName];
                            // Check if layerContent is array of entities
                            if (Array.isArray(layerContent)) {
                                // Inject layer name into entities if missing
                                layerContent.forEach(e => e.layer = layerName);
                                entities = entities.concat(layerContent);
                            } else if (layerContent.entities) {
                                layerContent.entities.forEach(e => e.layer = layerName);
                                entities = entities.concat(layerContent.entities);
                            }
                        }
                    }
                }

                logToScreen(`Found ${entities.length} potential entities.`);

                let lineCount = 0;

                // 배열 [x, y] 이나 {x, y} 모두를 처리해서 {x, y} 형태로 변환
                function toXY(p) {
                    if (!p) return null;

                    // [x, y] 형태
                    if (Array.isArray(p) && p.length >= 2) {
                        return { x: p[0], y: p[1] };
                    }

                    // 이미 {x, y} 형태
                    if (typeof p.x === "number" && typeof p.y === "number") {
                        return { x: p.x, y: p.y };
                    }

                    // 혹시 다른 형태면 포기
                    return null;
                }

                function createCadLine(p1, p2, color) {
                    const a = toXY(p1);
                    const b = toXY(p2);
                    if (!a || !b) return; // 좌표 해석 실패 시 무시

                    const v1 = new BABYLON.Vector3(a.x, 0, a.y);
                    const v2 = new BABYLON.Vector3(b.x, 0, b.y);
                    const lines = BABYLON.MeshBuilder.CreateLines("l", { points: [v1, v2] }, scene);
                    lines.color = color || BABYLON.Color3.Teal();
                    lines.parent = cadRoot;
                }

                if (entities.length > 0) {
                    entities.forEach(ent => {
                        let layerName = (ent.layer || ent.Layer || "").toUpperCase();

                        // Check Markers logic...
                        if (layerName === "A1") {
                            let pRaw = ent.position || ent.point || ent.center || ent.start;
                            const p = toXY(pRaw);
                            if (p) {
                                CAD_A1 = new BABYLON.Vector3(p.x, 0, p.y);
                                logToScreen(`Found A1: ${CAD_A1.x}, ${CAD_A1.z}`);
                            }
                        } else if (layerName === "A2") {
                            let pRaw = ent.position || ent.point || ent.center || ent.start;
                            const p = toXY(pRaw);
                            if (p) {
                                CAD_A2 = new BABYLON.Vector3(p.x, 0, p.y);
                                logToScreen(`Found A2: ${CAD_A2.x}, ${CAD_A2.z}`);
                            }
                        }

                        // Draw Lines
                        if ((ent.type === 'LINE' || ent.Type === 'LINE') && ent.start && ent.end) {
                            createCadLine(ent.start, ent.end);
                            lineCount++;
                        } else if (ent.vertices && ent.vertices.length > 1) {
                            for (let i = 0; i < ent.vertices.length - 1; i++) {
                                createCadLine(ent.vertices[i], ent.vertices[i + 1]);
                                lineCount++;
                            }
                        }
                    });
                }

                logToScreen(`Parsed Lines: ${lineCount}`);

                // Fallbacks if JSON structure was totally different
                if (lineCount === 0) {
                    logToScreen("WARN: Still 0 lines. Attempting brute force scan...");
                }

                // Fallbacks A1/A2 - Warn if missing
                if (!CAD_A1) {
                    logToScreen("WARN: A1 NOT FOUND in JSON!");
                    // CAD_A1 = new BABYLON.Vector3(1499.99, 0, 0); 
                }
                if (!CAD_A2) {
                    logToScreen("WARN: A2 NOT FOUND in JSON!");
                    // CAD_A2 = new BABYLON.Vector3(0, 0, 0); 
                }

                ui_status.text = `Ready. Lines: ${lineCount}`;

            } catch (e) {
                logToScreen("ERR JSON: " + e);
            }

            // --- WebXR ---
            let xr;
            try {
                xr = await scene.createDefaultXRExperienceAsync({
                    uiOptions: { sessionMode: "immersive-ar", referenceSpaceType: "local-floor" },
                    optionalFeatures: true
                });
            } catch (e) {
                ui_status.text = "XR Init Failed";
                return scene;
            }

            const fm = xr.baseExperience.featuresManager;
            const hitTest = fm.enableFeature(BABYLON.WebXRFeatureName.HIT_TEST, "latest");

            // --- RETICLE (3D Ring + Dot) ---
            // ===== 3D Reticle (원 + 중앙 점) =====
            const reticleRoot = new BABYLON.TransformNode("reticleRoot", scene);

            // 바깥 원
            const reticleRing = BABYLON.MeshBuilder.CreateTorus(
                "reticleRing",
                {
                    diameter: 0.18,     // 전체 지름
                    thickness: 0.01,    // 링 두께
                    tessellation: 48
                },
                scene
            );
            reticleRing.parent = reticleRoot;

            // 중앙 점
            const reticleDot = BABYLON.MeshBuilder.CreateDisc(
                "reticleDot",
                { radius: 0.01, tessellation: 32 },
                scene
            );
            reticleDot.parent = reticleRoot;
            reticleDot.position = new BABYLON.Vector3(0, 0.001, 0);

            // 머티리얼 (둘 다 흰색, 발광)
            const retMat = new BABYLON.StandardMaterial("reticleMat", scene);
            retMat.diffuseColor = BABYLON.Color3.White();
            retMat.emissiveColor = BABYLON.Color3.White();
            retMat.specularColor = new BABYLON.Color3(0, 0, 0);
            retMat.disableLighting = true;
            retMat.alpha = 0.8;

            reticleRing.material = retMat;
            reticleDot.material = retMat;

            // 처음에는 안 보이게 하고, hit 되면 켜도 됨
            reticleRoot.isVisible = true;

            // HitTest Loop
            let isHit = false;
            hitTest.onHitTestResultObservable.add((results) => {
                if (results.length) {
                    isHit = true;
                    reticleRoot.isVisible = true;

                    const hit = results[0];
                    if (Math.random() < 0.05) { // Log occasionally to avoid spamming too hard, or just log every frame if requested. User said "keep logging".
                        // Let's log every 60 frames or so? No, user said "continue logging". 
                        // But I'll just uncomment it.
                        logToScreen(`Hit: ${hit.position.x.toFixed(2)}, ${hit.position.y.toFixed(2)}, ${hit.position.z.toFixed(2)}`);
                    }

                    // 위치
                    reticleRoot.position.copyFrom(hit.position);

                    // 회전 : hit에 회전 정보가 있으면 그대로 사용
                    if (hit.rotationQuaternion) {
                        reticleRoot.rotationQuaternion = hit.rotationQuaternion.clone();
                    } else {
                        // 없으면 바닥(Y-up)에 눕혀두기
                        reticleRoot.rotationQuaternion = BABYLON.Quaternion.RotationAxis(
                            BABYLON.Axis.X,
                            Math.PI / 2
                        );
                    }
                } else {
                    isHit = false;
                    reticleRoot.isVisible = false;
                }
            });

            // --- Interaction ---
            // 화면 탭은 별도 동작 없음 (선택 버튼만 사용)
            scene.onPointerObservable.add(() => { });

            function performAlignment() {
                logToScreen("Aligning...");

                const b1Pos = World_b1.position;
                const b2Pos = World_b2.position;

                const worldVec = b2Pos.subtract(b1Pos);
                const cadVec = CAD_A2.subtract(CAD_A1);

                const worldDist = worldVec.length();
                const cadDist = cadVec.length();

                if (cadDist < 0.0001) { logToScreen("ERR: CAD points too close"); return; }

                const scale = worldDist / cadDist;

                const worldAngle = Math.atan2(worldVec.z, worldVec.x);
                const cadAngle = Math.atan2(cadVec.z, cadVec.x);
                const rotation = worldAngle - cadAngle;

                logToScreen(`S: ${scale.toFixed(5)}, R: ${(rotation * 180 / Math.PI).toFixed(1)}`);

                // Apply
                cadRoot.scaling = new BABYLON.Vector3(scale, scale, scale);

                const q = BABYLON.Quaternion.FromEulerAngles(0, -rotation, 0);
                const m = BABYLON.Matrix.Compose(
                    new BABYLON.Vector3(scale, scale, scale),
                    q,
                    BABYLON.Vector3.Zero()
                );

                const transformedA1 = BABYLON.Vector3.TransformCoordinates(CAD_A1, m);
                cadRoot.rotationQuaternion = q;
                cadRoot.position = b1Pos.subtract(transformedA1);

                cadRoot.setEnabled(true);
                cadRoot.setEnabled(true);
                ui_status.text = "";

                // Draw line between b1 and b2
                const conn = BABYLON.MeshBuilder.CreateLines("conn", { points: [b1Pos, b2Pos] }, scene);
                conn.color = BABYLON.Color3.White();
            }

            return scene;
        };

        createScene().then(sceneToRender => {
            engine.runRenderLoop(() => {
                sceneToRender.render();
            });
        }).catch(err => logToScreen(err));

        window.addEventListener("resize", () => engine.resize());
    </script>
</body>

</html>
