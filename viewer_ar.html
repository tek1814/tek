<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>DXF WebAR Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: #000;
    }
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
      display: block;
    }

    /* WebXR DOM Overlay(UI 컨테이너) */
    #ui-overlay {
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9999;
      font-family: system-ui, sans-serif;
    }

    /* + 모양 크로스헤어 */
    #crosshair {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 32px;
      height: 32px;
      margin-left: -16px;
      margin-top: -16px;
    }
    #crosshair::before,
    #crosshair::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      background: #fff;
    }
    #crosshair::before { /* 세로선 */
      width: 2px;
      height: 100%;
      transform: translate(-50%, -50%);
    }
    #crosshair::after {  /* 가로선 */
      width: 100%;
      height: 2px;
      transform: translate(-50%, -50%);
    }

    /* 아래 Anchor UI 패널 (조금 크게) */
    #ui-panel {
      position: absolute;
      left: 50%;
      bottom: 20px;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 14px;
      border-radius: 10px;
      color: #fff;
      font-size: 16px;
      pointer-events: auto;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #ui-panel span.label {
      font-weight: 500;
    }
    #ui-panel select {
      font-size: 16px;
      padding: 4px 10px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: #111;
      color: #fff;
    }

    /* 동그란 정렬 버튼 */
    #alignBtn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 2px solid #fff;
      background: #222;
      color: #fff;
      font-size: 16px;
      font-weight: 600;
      text-align: center;
      line-height: 52px;
      padding: 0;
    }
    #alignBtn:active {
      background: #444;
    }

    #status {
      margin-left: 4px;
      font-size: 12px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <!-- AR에서도 보이게 할 UI -->
  <div id="ui-overlay" class="dom-overlay-container">
    <div id="crosshair"></div>
    <div id="ui-panel">
      <span class="label">Anchor</span>
      <select id="anchorSelect">
        <option value="A1">A1</option>
        <option value="A2">A2</option>
      </select>
      <button id="alignBtn">정렬</button>
      <span id="status"></span>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    let xrHelper = null;
    let root = null;

    const mmToM = 0.001;
    let centerX = 0;
    let centerY = 0;
    let planAnchors = {};   // A1/A2 도면 좌표 (mm -> m 변환 전)
    const initialDistance = 2.0;

    const calibration = {
      first: null,   // { name, plan:{x,y}, world:{x,y,z} }
      second: null
    };

    function setStatus(text) {
      document.getElementById("status").textContent = text || "";
    }

    function toLocal(x, y) {
      // 도면 좌표(mm)를 root 로컬 좌표(m)로 변환 (아직 root의 회전/스케일 적용 전)
      const nx = (x - centerX) * mmToM;
      const nz = (y - centerY) * mmToM;
      return new BABYLON.Vector3(nx, 0, nz);
    }

    async function createScene() {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

      xrHelper = await scene.createDefaultXRExperienceAsync({
        uiOptions: {
          sessionMode: "immersive-ar",
          referenceSpaceType: "local-floor"
        }
      });

      // DOM Overlay 활성화
      const fm = xrHelper.baseExperience.featuresManager;
      fm.enableFeature(BABYLON.WebXRDomOverlay.Name, "latest", {
        element: "#ui-overlay"
      }, undefined, false);

      root = new BABYLON.TransformNode("root", scene);

      // 도면 JSON 로드
      const data = await fetch("Office_2.json").then(r => r.json());
      const layers = data.layers;

      // ----- 1) 바운딩 박스 계산 -----
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;

      function updateBounds(x, y) {
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }

      Object.keys(layers).forEach(layerName => {
        layers[layerName].forEach(e => {
          if (e.type === "LINE") {
            updateBounds(e.start[0], e.start[1]);
            updateBounds(e.end[0],   e.end[1]);
          } else if (e.type === "LWPOLYLINE") {
            e.points.forEach(p => updateBounds(p[0], p[1]));
          } else if (e.type === "CIRCLE" && e.center) {
            updateBounds(e.center[0], e.center[1]);
          }
        });
      });

      centerX = (minX + maxX) / 2;
      centerY = (minY + maxY) / 2;

      // ----- 2) A1, A2 기준점 도면좌표 추출 -----
      function extractAnchorFromLayer(layerName) {
        const ents = layers[layerName];
        if (!ents || ents.length === 0) return null;

        let eCircle = ents.find(e => e.type === "CIRCLE" || e.type === "circle");
        let e = eCircle || ents[0];

        let x, y;
        if (e.center && Array.isArray(e.center)) {
          x = e.center[0];
          y = e.center[1];
        } else if (Array.isArray(e.position)) {
          x = e.position[0];
          y = e.position[1];
        } else if (typeof e.cx === "number" && typeof e.cy === "number") {
          x = e.cx;
          y = e.cy;
        } else if (Array.isArray(e.points) && e.points.length > 0) {
          x = e.points[0][0];
          y = e.points[0][1];
        } else {
          return null;
        }
        return { x, y };
      }

      planAnchors.A1 = extractAnchorFromLayer("A1") || null;
      planAnchors.A2 = extractAnchorFromLayer("A2") || null;
      window.planAnchors = planAnchors;   // 디버깅용

      console.log("planAnchors:", planAnchors);

      // ----- 3) 도면 선 그리기 -----
      Object.keys(layers).forEach(layerName => {
        layers[layerName].forEach(e => {
          if (e.type === "LINE") {
            const p1 = toLocal(e.start[0], e.start[1]);
            const p2 = toLocal(e.end[0],   e.end[1]);
            const line = BABYLON.MeshBuilder.CreateLines("line", { points: [p1, p2] }, scene);
            line.parent = root;
            line.color = new BABYLON.Color3(1, 1, 0);
          } else if (e.type === "LWPOLYLINE") {
            if (!e.points || e.points.length < 2) return;
            const pts = e.points.map(p => toLocal(p[0], p[1]));
            const line = BABYLON.MeshBuilder.CreateLines("poly", { points: pts }, scene);
            line.parent = root;
            line.color = new BABYLON.Color3(1, 1, 0);
          }
        });
      });

      // ----- 4) AR 진입 시 카메라 앞 2m에 배치 -----
      xrHelper.baseExperience.onStateChangedObservable.add((state) => {
        if (state === BABYLON.WebXRState.IN_XR) {
          const cam = xrHelper.baseExperience.camera;
          const forward = cam.getForwardRay().direction;
          root.position = cam.position.add(forward.scale(initialDistance));
        }
      });

      // ----- 5) UI 이벤트 (정렬 버튼) -----
      const anchorSelect = document.getElementById("anchorSelect");
      const alignBtn = document.getElementById("alignBtn");

      alignBtn.addEventListener("click", () => {
        const currentName = anchorSelect.value; // "A1" or "A2"
        const plan = planAnchors[currentName];

        if (!plan) {
          setStatus(currentName + " 기준점 없음");
          return;
        }
        if (!xrHelper || !root) return;

        // (1) 크로스헤어가 가리키는 월드 좌표 (카메라 앞 2m)
        const cam = xrHelper.baseExperience.camera;
        const forward = cam.getForwardRay().direction;
        const targetWorld = cam.position.add(forward.scale(initialDistance));

        // (2) 단일 점 평행이동(빠른 피드백용): 현재 anchor를 target으로 이동
        const anchorLocalNow = toLocal(plan.x, plan.y);
        const anchorWorldNow = BABYLON.Vector3.TransformCoordinates(
          anchorLocalNow,
          root.getWorldMatrix()
        );
        const delta = targetWorld.subtract(anchorWorldNow);
        root.position = root.position.add(delta);

        // (3) 두 점 정합을 위한 샘플 저장
        const entry = {
          name: currentName,
          plan: { x: plan.x, y: plan.y },
          world: { x: targetWorld.x, y: targetWorld.y, z: targetWorld.z }
        };

        if (!calibration.first || calibration.first.name === currentName) {
          calibration.first = entry;
          calibration.second = null; // 같은 기준점을 다시 찍으면 첫 점만 갱신
          setStatus(currentName + " 1점 저장");
          return;
        } else {
          calibration.second = entry;
        }

        // (4) 서로 다른 두 기준점이 모두 준비되면
        const p1 = calibration.first;
        const p2 = calibration.second;

        // 도면 로컬 좌표 (m)
        const v1 = toLocal(p1.plan.x, p1.plan.y);
        const v2 = toLocal(p2.plan.x, p2.plan.y);
        const a1 = new BABYLON.Vector2(v1.x, v1.z);
        const a2 = new BABYLON.Vector2(v2.x, v2.z);

        // 현실 월드 좌표 (XZ 평면만 사용)
        const b1 = new BABYLON.Vector2(p1.world.x, p1.world.z);
        const b2 = new BABYLON.Vector2(p2.world.x, p2.world.z);

        const da = a2.subtract(a1);
        const db = b2.subtract(b1);
        const lenA = da.length();
        const lenB = db.length();
        if (lenA < 1e-6 || lenB < 1e-6) {
          setStatus("기준점 간 거리가 너무 짧음");
          return;
        }

        // 스케일
        const s = lenB / lenA;

        // 회전 (Y축 회전)
        const angleA = Math.atan2(da.y, da.x);
        const angleB = Math.atan2(db.y, db.x);
        const theta = angleB - angleA;

        const cosT = Math.cos(theta);
        const sinT = Math.sin(theta);

        // 평행이동 t:  b1 = R*s*a1 + t
        const ax1 = a1.x * s;
        const az1 = a1.y * s;
        const rx1 = cosT * ax1 - sinT * az1;
        const rz1 = sinT * ax1 + cosT * az1;

        const tx = b1.x - rx1;
        const tz = b1.y - rz1;
        const ty = p1.world.y;   // 높이는 첫 번째 점의 높이 기준

        // (5) root에 최종 변환 적용
        root.scaling = new BABYLON.Vector3(s, s, s);
        root.rotation = new BABYLON.Vector3(0, theta, 0);
        root.position = new BABYLON.Vector3(tx, ty, tz);

        setStatus("두 점 정합 완료 (" + calibration.first.name + ", " + calibration.second.name + ")");
        // 필요하면 calibration 상태를 유지해서 나중에 다시 사용할 수도 있음
      });

      return scene;
    }

    createScene().then(scene => {
      engine.runRenderLoop(() => scene.render());
    });
    window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>
