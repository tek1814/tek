<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>DXF WebAR Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <script src="https://cdn.babylonjs.com/babylon.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: #000;
    }
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
      display: block;
    }

    /* 전체 UI 컨테이너 */
    #ui-overlay {
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9999;
      font-family: system-ui, sans-serif;
    }

    /* + 모양 크로스헤어 */
    #crosshair {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 40px;
      height: 40px;
      margin-left: -20px;
      margin-top: -20px;
    }
    #crosshair::before,
    #crosshair::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      background: #fff;
    }
    #crosshair::before { /* vertical */
      width: 2px;
      height: 100%;
      transform: translate(-50%, -50%);
    }
    #crosshair::after {  /* horizontal */
      width: 100%;
      height: 2px;
      transform: translate(-50%, -50%);
    }

    /* 아래 Anchor UI 패널 */
    #ui-panel {
      position: absolute;
      left: 50%;
      bottom: 20px;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 12px 18px;
      border-radius: 12px;
      color: #fff;
      font-size: 16px;
      pointer-events: auto;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #ui-panel span.label {
      font-weight: 600;
    }
    #ui-panel select {
      font-size: 16px;
      padding: 4px 10px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: #111;
      color: #fff;
    }

    /* 동그란 '선택' 버튼 */
    #selectBtn {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      border: 2px solid #fff;
      background: #222;
      color: #fff;
      font-size: 18px;
      font-weight: 600;
      text-align: center;
      line-height: 60px;
      padding: 0;
    }
    #selectBtn:active {
      background: #444;
    }

    #status {
      margin-left: 4px;
      font-size: 12px;
      opacity: 0.9;
      max-width: 160px;
    }
  </style>
</head>

<body>
  <canvas id="renderCanvas"></canvas>

  <!-- AR UI -->
  <div id="ui-overlay" class="dom-overlay-container">
    <div id="crosshair"></div>

    <div id="ui-panel">
      <span class="label">Anchor</span>
      <select id="anchorSelect">
        <option value="A1">A1</option>
        <option value="A2">A2</option>
      </select>

      <button id="selectBtn">선택</button>
      <span id="status"></span>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    let xrHelper = null;
    let root = null;

    const mmToM = 0.001;
    let centerX = 0;
    let centerY = 0;

    // 도면 기준점 (A1/A2) 좌표: { A1:{x,y}, A2:{x,y}, ... }
    const planAnchors = {};

    // 사용자가 선택한 현실 기준점 좌표: { A1:Vector3, A2:Vector3, ... }
    const worldAnchors = {};

    // HitTest feature와 결과
    let xrHitTestFeature = null;
    let lastHitPosition = null;  // 실제 바닥/벽 hit 위치
    let hitTestAvailable = false;

    function setStatus(msg) {
      document.getElementById("status").textContent = msg || "";
    }

    // 도면 좌표(mm)를 root 로컬 좌표(m)로 변환
    function toLocal(x, y) {
      const nx = (x - centerX) * mmToM;
      const nz = (y - centerY) * mmToM;
      return new BABYLON.Vector3(nx, 0, nz);
    }

    // 크로스헤어가 가리키는 세계 좌표:
    // 1순위: HitTest 결과
    // 2순위: 카메라 앞 2m
    function getCrosshairWorldPosition() {
      if (hitTestAvailable && lastHitPosition) {
        return lastHitPosition.clone();
      }
      if (!xrHelper) return BABYLON.Vector3.Zero();
      const cam = xrHelper.baseExperience.camera;
      const forward = cam.getForwardRay().direction;
      const distance = 2.0;
      return cam.position.add(forward.scale(distance));
    }

    // 두 Anchor(name1,name2)를 이용해 회전+평행이동(스케일=1) 한 번에 적용
    function applyTwoPointAlignment(name1, name2) {
      const plan1 = planAnchors[name1];
      const plan2 = planAnchors[name2];
      const world1 = worldAnchors[name1];
      const world2 = worldAnchors[name2];

      if (!plan1 || !plan2 || !world1 || !world2) {
        return;
      }

      // 도면(로컬) 좌표
      const v1 = toLocal(plan1.x, plan1.y);
      const v2 = toLocal(plan2.x, plan2.y);
      const a1 = new BABYLON.Vector2(v1.x, v1.z);
      const a2 = new BABYLON.Vector2(v2.x, v2.z);

      // 현실(XZ 평면)
      const b1 = new BABYLON.Vector2(world1.x, world1.z);
      const b2 = new BABYLON.Vector2(world2.x, world2.z);

      const da = a2.subtract(a1);
      const db = b2.subtract(b1);
      const lenA = da.length();
      const lenB = db.length();

      if (lenA < 1e-6 || lenB < 1e-6) {
        setStatus("기준점 간 거리가 너무 짧음");
        return;
      }

      // 스케일은 도면이 정확하다고 보고 1.0 고정
      const s = 1.0;

      // 회전(Y축)
      const angleA = Math.atan2(da.y, da.x);
      const angleB = Math.atan2(db.y, db.x);
      const theta = angleB - angleA;
      const cosT = Math.cos(theta);
      const sinT = Math.sin(theta);

      // 평행이동: b1 = R * a1 + t  (s=1)
      const ax1 = a1.x;
      const az1 = a1.y;
      const rx1 = cosT * ax1 - sinT * az1;
      const rz1 = sinT * ax1 + cosT * az1;

      const tx = b1.x - rx1;
      const tz = b1.y - rz1;
      const ty = world1.y;  // 높이는 첫 번째 기준점의 높이

      // root 변환을 한 번에 설정
      root.scaling = new BABYLON.Vector3(1, 1, 1);
      root.rotation = new BABYLON.Vector3(0, theta, 0);
      root.position = new BABYLON.Vector3(tx, ty, tz);

      setStatus("정합 완료 (" + name1 + ", " + name2 + ")");
    }

    async function createScene() {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

      xrHelper = await scene.createDefaultXRExperienceAsync({
        uiOptions: {
          sessionMode: "immersive-ar",
          referenceSpaceType: "local-floor"
        }
      });

      const fm = xrHelper.baseExperience.featuresManager;

      // DOM Overlay 활성화 (AR에서도 UI 보이게)
      fm.enableFeature(BABYLON.WebXRDomOverlay.Name, "latest", {
        element: "#ui-overlay"
      }, undefined, false);

      // HitTest 기능 활성화 시도
      try {
        xrHitTestFeature = fm.enableFeature(BABYLON.WebXRFeatureName.HIT_TEST, "latest");
        if (xrHitTestFeature && xrHitTestFeature.onHitTestResultObservable) {
          xrHitTestFeature.onHitTestResultObservable.add((results) => {
            if (results.length) {
              if (!lastHitPosition) {
                lastHitPosition = new BABYLON.Vector3();
              }
              const hit = results[0];
              hit.transformationMatrix.decompose(
                undefined,
                undefined,
                lastHitPosition
              );
              hitTestAvailable = true;
              // 상태는 너무 자주 바뀌지 않도록 간단히 표시만:
              // setStatus("HitTest OK");
            } else {
              // hit이 잠시 없어져도, 마지막 성공 위치는 유지
              // hitTestAvailable = false;  // 굳이 false로 내리지 않음
            }
          });
        } else {
          setStatus("HitTest 기능 없음, 2m fallback 사용");
        }
      } catch (e) {
        console.warn("HitTest enable 실패:", e);
        setStatus("HitTest 실패, 2m fallback 사용");
      }

      root = new BABYLON.TransformNode("root", scene);

      // JSON 로드
      const data = await fetch("Office_2.json").then(r => r.json());
      const layers = data.layers;

      // 1) 바운딩 박스
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;

      function updateBounds(x, y) {
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }

      Object.keys(layers).forEach(layerName => {
        layers[layerName].forEach(e => {
          if (e.type === "LINE") {
            updateBounds(e.start[0], e.start[1]);
            updateBounds(e.end[0],   e.end[1]);
          } else if (e.type === "LWPOLYLINE") {
            e.points.forEach(p => updateBounds(p[0], p[1]));
          } else if (e.type === "CIRCLE" && e.center) {
            updateBounds(e.center[0], e.center[1]);
          }
        });
      });

      centerX = (minX + maxX) / 2;
      centerY = (minY + maxY) / 2;

      // 2) A1, A2 기준점 추출
      function extractAnchor(layerName) {
        const ents = layers[layerName];
        if (!ents || ents.length === 0) return null;
        const c = ents.find(e => e.type === "CIRCLE");
        if (c && c.center) {
          return { x: c.center[0], y: c.center[1] };
        }
        const p = ents[0];
        if (p.points && p.points.length) {
          return { x: p.points[0][0], y: p.points[0][1] };
        }
        return null;
      }

      planAnchors.A1 = extractAnchor("A1");
      planAnchors.A2 = extractAnchor("A2");

      console.log("planAnchors:", planAnchors);

      // 3) 도면 선 그리기
      Object.keys(layers).forEach(layerName => {
        layers[layerName].forEach(e => {
          if (e.type === "LINE") {
            const p1 = toLocal(e.start[0], e.start[1]);
            const p2 = toLocal(e.end[0],   e.end[1]);
            const line = BABYLON.MeshBuilder.CreateLines("line", { points: [p1, p2] }, scene);
            line.parent = root;
            line.color = new BABYLON.Color3(1, 1, 0);
          } else if (e.type === "LWPOLYLINE") {
            if (!e.points || e.points.length < 2) return;
            const pts = e.points.map(pt => toLocal(pt[0], pt[1]));
            const line = BABYLON.MeshBuilder.CreateLines("poly", { points: pts }, scene);
            line.parent = root;
            line.color = new BABYLON.Color3(1, 1, 0);
          }
        });
      });

      // AR 진입 시 초기 위치 = 카메라 앞 2m (대략적인 위치 표시용)
      xrHelper.baseExperience.onStateChangedObservable.add(state => {
        if (state === BABYLON.WebXRState.IN_XR) {
          const cam = xrHelper.baseExperience.camera;
          const f = cam.getForwardRay().direction;
          root.position = cam.position.add(f.scale(2.0));
          setStatus(hitTestAvailable ? "AR 준비됨 (HitTest 사용 가능)" : "AR 준비됨 (2m fallback)");
        }
      });

      // 4) UI 이벤트: Anchor 선택 + '선택' 버튼
      const anchorSelect = document.getElementById("anchorSelect");
      const selectBtn = document.getElementById("selectBtn");

      selectBtn.addEventListener("click", () => {
        const name = anchorSelect.value;   // "A1" 또는 "A2"
        const plan = planAnchors[name];
        if (!plan) {
          setStatus(name + " 도면 기준점 없음");
          return;
        }

        const worldPos = getCrosshairWorldPosition();
        worldAnchors[name] = worldPos.clone();

        if (hitTestAvailable && lastHitPosition) {
          setStatus(name + " 선택 (HitTest)");
        } else {
          setStatus(name + " 선택 (2m fallback)");
        }

        // A1, A2가 둘 다 선택된 경우 자동 정합
        if (worldAnchors["A1"] && worldAnchors["A2"]) {
          applyTwoPointAlignment("A1", "A2");
        }
      });

      return scene;
    }

    createScene().then(scene => {
      engine.runRenderLoop(() => scene.render());
    });

    window.addEventListener("resize", () => engine.resize());
  </script>

</body>
</html>
