<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>DXF WebAR Viewer</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
      display: block;
    }
    /* UI 오버레이 */
    #ui-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none; /* 기본은 AR 제스처 방해 X */
    }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 24px;
      height: 24px;
      box-sizing: border-box;
      border-left: 2px solid rgba(255,255,255,0.8);
      border-right: 2px solid rgba(255,255,255,0.8);
      border-top: 2px solid rgba(255,255,255,0.8);
      border-bottom: 2px solid rgba(255,255,255,0.8);
      border-radius: 4px;
    }
    #control-panel {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      border-radius: 8px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-size: 14px;
      pointer-events: auto; /* 이 패널만 클릭 가능 */
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #control-panel select,
    #control-panel button {
      font-size: 14px;
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <!-- AR 기준점 UI -->
  <div id="ui-overlay">
    <div id="crosshair"></div>
    <div id="control-panel">
      <span>Anchor:</span>
      <select id="anchorSelect">
        <option value="A1">A1</option>
        <option value="A2">A2</option>
      </select>
      <button id="captureBtn">현재 위치에 정렬</button>
    </div>
  </div>

  <script>
  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true);

  // B1/B2 저장용 (월드 좌표, XZ 평면)
  const BAnchors = {
    A1: null,
    A2: null,
  };

  async function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0, 0, 0, 0); // 투명 배경

    // XR (AR) 세션 준비
    const xrHelper = await scene.createDefaultXRExperienceAsync({
      uiOptions: {
        sessionMode: "immersive-ar",
        referenceSpaceType: "local-floor"
      },
      optionalFeatures: true
    });

    const root = new BABYLON.TransformNode("root", scene);

    // 도면 JSON 로드
    const data = await fetch("Office.json").then(r => r.json());
    const layers = data.layers;

    // 바운딩 박스 계산
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    function updateBounds(x, y) {
      if (x < minX) minX = x;
      if (x > maxX) maxX = x;
      if (y < minY) minY = y;
      if (y > maxY) maxY = y;
    }

    Object.keys(layers).forEach(layer => {
      layers[layer].forEach(e => {
        if (e.type === "LINE") {
          updateBounds(e.start[0], e.start[1]);
          updateBounds(e.end[0],   e.end[1]);
        } else if (e.type === "LWPOLYLINE") {
          e.points.forEach(p => updateBounds(p[0], p[1]));
        }
      });
    });

    // mm → m 스케일 및 중심
    const mmToM = 0.001;
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;

    function toWorld(x, y) {
      const nx = (x - cx) * mmToM;
      const nz = (y - cy) * mmToM;
      return new BABYLON.Vector3(nx, 0, nz);
    }

    // 도면 선 그리기
    Object.keys(layers).forEach(layer => {
      layers[layer].forEach(e => {
        if (e.type === "LINE") {
          const pts = [
            toWorld(e.start[0], e.start[1]),
            toWorld(e.end[0],   e.end[1]),
          ];
          const line = BABYLON.MeshBuilder.CreateLines("line", { points: pts }, scene);
          line.parent = root;
          line.color = new BABYLON.Color3(1, 1, 0);   // 노란색
        } else if (e.type === "LWPOLYLINE") {
          if (!e.points || e.points.length < 2) return;
          const pts = e.points.map(p => toWorld(p[0], p[1]));
          const line = BABYLON.MeshBuilder.CreateLines("poly", { points: pts }, scene);
          line.parent = root;
          line.color = new BABYLON.Color3(1, 1, 0);
        }
      });
    });

    // 도면 내부 기준점(A1/A2)의 "로컬 좌표" (XZ 평면) 계산
    let localAnchors = null;
    function computeLocalAnchors() {
      if (!window.planAnchors) {
        console.warn("planAnchors 없음 (SVG 로드 전일 수 있음)");
        return;
      }
      const A1p = window.planAnchors.A1;
      const A2p = window.planAnchors.A2;
      const v1 = toWorld(A1p.x, A1p.y); // Vector3
      const v2 = toWorld(A2p.x, A2p.y);

      localAnchors = {
        A1: new BABYLON.Vector2(v1.x, v1.z),
        A2: new BABYLON.Vector2(v2.x, v2.z),
      };
      console.log("Local anchors:", localAnchors);
    }
    computeLocalAnchors();

    // 처음에는 카메라 앞 2m 지점에 도면을 둔다.
    const initialDistance = 2.0;
    xrHelper.baseExperience.onStateChangedObservable.add((state) => {
      if (state === BABYLON.WebXRState.IN_XR) {
        const cam = xrHelper.baseExperience.camera;
        const forward = cam.getForwardRay().direction;
        root.position = cam.position.add(forward.scale(initialDistance));
      }
    });

    // A1/A2 & B1/B2가 모두 준비되면 정합을 수행
    function alignIfReady() {
      if (!localAnchors) {
        computeLocalAnchors();
      }
      if (!localAnchors) {
        console.warn("localAnchors 없음 (SVG 기준점 미계산)");
        return;
      }
      if (!BAnchors.A1 || !BAnchors.A2) {
        // 아직 두 점 다 안 찍음
        return;
      }

      const A1 = localAnchors.A1; // Vector2 (x,z)
      const A2 = localAnchors.A2;
      const B1 = BAnchors.A1;    // Vector2 (x,z)
      const B2 = BAnchors.A2;

      // 벡터 계산
      const vA = A2.subtract(A1);
      const vB = B2.subtract(B1);
      const lenA = vA.length();
      const lenB = vB.length();
      if (lenA < 1e-6 || lenB < 1e-6) {
        console.warn("Anchor 길이가 너무 짧음");
        return;
      }

      // 스케일
      const scale = lenB / lenA;

      // 회전 (XZ 평면)
      const angleA = Math.atan2(vA.y, vA.x); // y = z축
      const angleB = Math.atan2(vB.y, vB.x);
      const rotation = angleB - angleA;

      const cos = Math.cos(rotation);
      const sin = Math.sin(rotation);

      // A1을 원점으로 이동 후 회전+스케일 → 다시 평행이동해서 B1에 맞춤
      const ax = scale * (A1.x * cos - A1.y * sin);
      const az = scale * (A1.x * sin + A1.y * cos);

      const tx = B1.x - ax;
      const tz = B1.y - az;

      // root 노드에 적용 (Y축 회전)
      root.scaling = new BABYLON.Vector3(scale, scale, scale);
      root.rotation = new BABYLON.Vector3(0, rotation, 0);
      root.position = new BABYLON.Vector3(tx, 0, tz);

      console.log("Alignment applied:", { scale, rotation, tx, tz });
    }

    // UI 버튼 이벤트: 현재 크로스헤어 위치를 선택된 Anchor(B1/B2)로 저장
    const anchorSelect = document.getElementById("anchorSelect");
    const captureBtn = document.getElementById("captureBtn");

    captureBtn.addEventListener("click", () => {
      const current = anchorSelect.value; // "A1" or "A2"

      // XR 카메라 기준으로, 전방 initialDistance 떨어진 지점을 B로 사용
      const cam = xrHelper.baseExperience.camera;
      const forward = cam.getForwardRay().direction;
      const pos = cam.position.add(forward.scale(initialDistance));

      // XZ 평면상의 2D 좌표로 저장
      BAnchors[current] = new BABYLON.Vector2(pos.x, pos.z);
      console.log("Captured", current, BAnchors[current]);

      alignIfReady();
    });

    return scene;
  }

  createScene().then(scene => {
    engine.runRenderLoop(() => scene.render());
  });

  window.addEventListener("resize", () => {
    engine.resize();
  });
  </script>

  <!-- SVG에서 A1/A2 읽어오는 스크립트 (이미 만들어 둔 것) -->
  <script src="./js/plan-ar.js"></script>
</body>
</html>
