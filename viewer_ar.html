<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>DXF WebAR Viewer</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
</head>
<body style="margin:0;">
<canvas id="renderCanvas" style="width:100%; height:100%; touch-action:none;"></canvas>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

async function createScene() {
  const scene = new BABYLON.Scene(engine);
  scene.clearColor = new BABYLON.Color4(0, 0, 0, 0); // 투명 배경

  // XR (AR) 세션 준비
  const xrHelper = await scene.createDefaultXRExperienceAsync({
    uiOptions: {
      sessionMode: "immersive-ar",
      referenceSpaceType: "local-floor"
    },
    optionalFeatures: true
  });

  const root = new BABYLON.TransformNode("root", scene);

  // 도면 JSON 로드
  const data = await fetch("Office.json").then(r => r.json());
  const layers = data.layers;

  // 바운딩 박스 계산
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;

  function updateBounds(x, y) {
    if (x < minX) minX = x;
    if (x > maxX) maxX = x;
    if (y < minY) minY = y;
    if (y > maxY) maxY = y;
  }

  Object.keys(layers).forEach(layer => {
    layers[layer].forEach(e => {
      if (e.type === "LINE") {
        updateBounds(e.start[0], e.start[1]);
        updateBounds(e.end[0],   e.end[1]);
      } else if (e.type === "LWPOLYLINE") {
        e.points.forEach(p => updateBounds(p[0], p[1]));
      }
    });
  });

  const mmToM = 0.001;
  const cx = (minX + maxX) / 2;
  const cy = (minY + maxY) / 2;

  function toWorld(x, y) {
    const nx = (x - cx) * mmToM;
    const nz = (y - cy) * mmToM;
    return new BABYLON.Vector3(nx, 0, nz);
  }

  // 도면 선 그리기
  Object.keys(layers).forEach(layer => {
    layers[layer].forEach(e => {
      if (e.type === "LINE") {
        const pts = [
          toWorld(e.start[0], e.start[1]),
          toWorld(e.end[0],   e.end[1]),
        ];
        const line = BABYLON.MeshBuilder.CreateLines("line", { points: pts }, scene);
        line.parent = root;
        line.color = new BABYLON.Color3(1, 1, 0);   // 노란색
      } else if (e.type === "LWPOLYLINE") {
        if (!e.points || e.points.length < 2) return;
        const pts = e.points.map(p => toWorld(p[0], p[1]));
        const line = BABYLON.MeshBuilder.CreateLines("poly", { points: pts }, scene);
        line.parent = root;
        line.color = new BABYLON.Color3(1, 1, 0);
      }
    });
  });

  // 처음에는 카메라 앞 2m 지점에 도면을 둔다.
  xrHelper.baseExperience.onStateChangedObservable.add((state) => {
    if (state === BABYLON.WebXRState.IN_XR) {
      const cam = xrHelper.baseExperience.camera;
      const forward = cam.getForwardRay().direction;
      const distance = 2.0;
      root.position = cam.position.add(forward.scale(distance));
    }
  });

  return scene;
}

createScene().then(scene => {
  engine.runRenderLoop(() => scene.render());
});

window.addEventListener("resize", () => {
  engine.resize();
});
</script>
</body>
</html>

