<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>DXF WebAR Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: #000;
    }

    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
      display: block;
    }

    /* WebXR DOM Overlay용 컨테이너 */
    #ui-overlay {
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;          /* 기본은 클릭 막기 */
      z-index: 9999;
      font-family: system-ui, sans-serif;
    }

    /* 가운데 + 모양 크로스헤어 */
    #crosshair {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 32px;
      height: 32px;
      margin-left: -16px;
      margin-top: -16px;
    }
    #crosshair::before,
    #crosshair::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      background: #fff;
    }
    /* 세로선 */
    #crosshair::before {
      width: 2px;
      height: 100%;
      transform: translate(-50%, -50%);
    }
    /* 가로선 */
    #crosshair::after {
      width: 100%;
      height: 2px;
      transform: translate(-50%, -50%);
    }

    /* 아래쪽 UI 패널 */
    #ui-panel {
      position: absolute;
      left: 50%;
      bottom: 12px;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      padding: 6px 10px;
      border-radius: 6px;
      color: #fff;
      font-size: 14px;
      pointer-events: auto;          /* 패널은 클릭 가능 */
      display: flex;
      align-items: center;
      gap: 4px;
    }

    #ui-panel select,
    #ui-panel button {
      font-size: 14px;
    }

    label {
      margin-right: 4px;
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <!-- AR에서도 보이게 만들 WebXR DOM Overlay -->
  <div id="ui-overlay" class="dom-overlay-container">
    <div id="crosshair"></div>
    <div id="ui-panel">
      <label for="anchorSelect">Anchor:</label>
      <select id="anchorSelect">
        <option value="A1">A1</option>
        <option value="A2">A2</option>
      </select>
      <button id="alignBtn">현재 위치에 정렬</button>
    </div>
  </div>

  <!-- SVG에서 A1/A2 좌표 읽어오는 스크립트 -->
  <script src="./js/plan-ar.js"></script>

  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);
    let root;
    let xrHelper;
    let currentAnchorName = "A1";

    // plan-ar.js에서 채워주는 기준점 (SVG의 cx, cy 값)
    // 예: window.planAnchors = { A1:{x:..,y:..}, A2:{x:..,y:..} }
    let planAnchors = null;

    async function createScene() {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

      // XR (AR) 기본 설정
      xrHelper = await scene.createDefaultXRExperienceAsync({
        uiOptions: {
          sessionMode: "immersive-ar",
          referenceSpaceType: "local-floor"
        }
      });

      // ★ WebXR DOM Overlay 활성화 (핵심)
      const fm = xrHelper.baseExperience.featuresManager;
      fm.enableFeature(BABYLON.WebXRDomOverlay.Name, "latest", {
        element: "#ui-overlay"
      }, undefined, false);

      root = new BABYLON.TransformNode("root", scene);

      // DXF → JSON에서 도면 그리기 (기존 코드 그대로)
      const data = await fetch("Office.json").then(r => r.json());
      const layers = data.layers;

      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;

      function updateBounds(x, y) {
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }

      Object.keys(layers).forEach(layer => {
        layers[layer].forEach(e => {
          if (e.type === "LINE") {
            updateBounds(e.start[0], e.start[1]);
            updateBounds(e.end[0],   e.end[1]);
          } else if (e.type === "LWPOLYLINE") {
            e.points.forEach(p => updateBounds(p[0], p[1]));
          }
        });
      });

      const mmToM = 0.001;
      const cx = (minX + maxX) / 2;
      const cy = (minY + maxY) / 2;

      function toWorld(x, y) {
        const nx = (x - cx) * mmToM;
        const nz = (y - cy) * mmToM;
        return new BABYLON.Vector3(nx, 0, nz);
      }

      Object.keys(layers).forEach(layer => {
        layers[layer].forEach(e => {
          if (e.type === "LINE") {
            const pts = [
              toWorld(e.start[0], e.start[1]),
              toWorld(e.end[0],   e.end[1]),
            ];
            const line = BABYLON.MeshBuilder.CreateLines("line", { points: pts }, scene);
            line.parent = root;
            line.color = new BABYLON.Color3(1, 1, 0);
          } else if (e.type === "LWPOLYLINE") {
            if (!e.points || e.points.length < 2) return;
            const pts = e.points.map(p => toWorld(p[0], p[1]));
            const line = BABYLON.MeshBuilder.CreateLines("poly", { points: pts }, scene);
            line.parent = root;
            line.color = new BABYLON.Color3(1, 1, 0);
          }
        });
      });

      // AR에 들어갈 때, 처음 위치(카메라 앞 2m)에 도면 두기
      xrHelper.baseExperience.onStateChangedObservable.add((state) => {
        if (state === BABYLON.WebXRState.IN_XR) {
          const cam = xrHelper.baseExperience.camera;
          const fwd = cam.getForwardRay().direction;
          const dist = 2.0;
          root.position = cam.position.add(fwd.scale(dist));
        }
      });

      return scene;
    }

    // 크로스헤어가 가리키는 세계 좌표 (카메라 앞 2m 지점)
    function getCurrentCrosshairWorldPos() {
      if (!xrHelper) return null;
      const cam = xrHelper.baseExperience.camera;
      const forward = cam.getForwardRay().direction;
      const distance = 2.0;
      return cam.position.add(forward.scale(distance));
    }

    // 선택한 Anchor를 현재 크로스헤어 위치에 1점 정렬 (우선: 평행이동만)
    function alignCurrentAnchor() {
      if (!planAnchors || !planAnchors[currentAnchorName]) {
        console.warn("planAnchors 가 없거나", currentAnchorName, "를 찾지 못했습니다.");
        return;
      }
      const worldPos = getCurrentCrosshairWorldPos();
      if (!worldPos) return;

      const anchorPlan = planAnchors[currentAnchorName]; // {x, y} (SVG 좌표)
      // 도면 좌표계에서 anchor의 world 좌표 (root 기준)
      const mmToM = 0.001;

      // viewer_ar.html에서 쓴 것과 동일한 중심 보정을 다시 사용해야 정확하지만
      // 데모용으로는 anchorPlan.x, y 만 사용해서 근사 정렬
      const anchorLocal = new BABYLON.Vector3(
        anchorPlan.x * mmToM,
        0,
        anchorPlan.y * mmToM
      );

      // 현재 root 기준 world 좌표로 변환
      const anchorWorld = BABYLON.Vector3.TransformCoordinates(
        anchorLocal,
        root.getWorldMatrix()
      );

      // anchorWorld → worldPos 로 이동하는 평행이동 벡터
      const delta = worldPos.subtract(anchorWorld);

      root.position = root.position.add(delta);
    }

    // UI 이벤트
    document.getElementById("anchorSelect").addEventListener("change", (e) => {
      currentAnchorName = e.target.value;
    });

    document.getElementById("alignBtn").addEventListener("click", () => {
      alignCurrentAnchor();
    });

    // SVG에서 A1/A2 읽어오기
    // (plan-ar.js 안에 있는 전역 함수라고 가정)
    loadSvgWithAnchors("assets/svg/Office_2.svg").then(res => {
      // res = { A1:{x:..,y:..}, A2:{x:..,y:..} }
      planAnchors = res;
      console.log("planAnchors:", planAnchors);
    }).catch(err => {
      console.error("SVG anchor 로드 실패:", err);
    });

    // Babylon 시작
    createScene().then(scene => {
      engine.runRenderLoop(() => scene.render());
    });
    window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>
