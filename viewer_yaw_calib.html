<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>AR Plan Alignment (A1–A2 ↔ B1–B2)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#000; color:#fff; }
    #overlay { position:fixed; inset:0; pointer-events:none; }
    #center-dot {
      position:absolute; left:50%; top:50%; transform:translate(-50%, -50%);
      width:8px; height:8px; background:#fff; border-radius:50%;
    }
    #ui {
      position:absolute; bottom:20px; left:50%; transform:translateX(-50%);
      display:flex; flex-direction:column; gap:6px; align-items:center;
      pointer-events:auto;
    }
    select, button {
      padding:8px 14px; border-radius:999px; font-size:13px;
      border:none; background:#007aff; color:#fff;
    }
    #status, #result { font-size:12px; text-align:center; white-space:pre-line; }
    #result { margin-top:6px; max-width:90vw; }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="center-dot"></div>
    <div id="ui">
      <select id="selectPoint" disabled>
        <option value="B1">B1</option>
        <option value="B2">B2</option>
      </select>
      <button id="btnMain">START AR</button>
      <div id="status">상태: 준비</div>
      <div id="result"></div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.155/build/three.module.js";

    // ============================================================
    // ---------------------- 기본 세팅 ----------------------------
    // ============================================================
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 50);

    const renderer = new THREE.WebGLRenderer({ alpha:true, antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
    scene.add(light);

    // 바닥 hit-test용 레티클
    const reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.03, 0.035, 32),
      new THREE.MeshBasicMaterial({ color:0xffffff })
    );
    reticle.rotation.x = -Math.PI/2;
    reticle.visible = false;
    scene.add(reticle);

    // UI
    const selectPoint = document.getElementById("selectPoint");
    const btnMain = document.getElementById("btnMain");
    const statusBox = document.getElementById("status");
    const resultBox = document.getElementById("result");

    function setStatus(msg){ statusBox.textContent = "상태: " + msg; }
    function setResult(msg){ resultBox.textContent = msg; }

    // ============================================================
    // -------------------- 도면 데이터 ----------------------------
    // ============================================================
    const MM = 0.001;
    let A1 = null, A2 = null;         // THREE.Vector3 (m), (x,0,z=y)
    let segs = [];                    // 각 선분 {x1,y1,x2,y2}
    const planGroup = new THREE.Group();
    scene.add(planGroup);

    async function loadPlan(){
      const json = await (await fetch("./Office_2.json")).json();
      const layers = json.layers ?? json;

      // A1/A2 중심점
      const [A1_mm_x, A1_mm_y] = layers.A1[0].center;
      const [A2_mm_x, A2_mm_y] = layers.A2[0].center;
      A1 = new THREE.Vector3(A1_mm_x*MM, 0, A1_mm_y*MM);
      A2 = new THREE.Vector3(A2_mm_x*MM, 0, A2_mm_y*MM);

      // 도면 선분 추출
      for (const [layer, ents] of Object.entries(layers)){
        if (!Array.isArray(ents)) continue;
        if (layer === "A1" || layer === "A2") continue;
        for (const e of ents){
          if (e.type==="LINE"){
            const [x1,y1]=e.start, [x2,y2]=e.end;
            segs.push({x1,y1,x2,y2});
          }
          if (e.type==="LWPOLYLINE"){
            for (let i=0;i<e.points.length-1;i++){
              const [x1,y1]=e.points[i], [x2,y2]=e.points[i+1];
              segs.push({x1,y1,x2,y2});
            }
          }
        }
      }
      setStatus("도면 로드 완료");
    }
    loadPlan();

    // ============================================================
    // --------------- 정합에 필요한 상태 -------------------------
    // ============================================================
    let B1 = null, B2 = null;         // THREE.Vector3 (m)
    let first = null;                 // "B1" or "B2" ← anchor
    let gScale = 1, gYaw = 0;
    let gTrans = new THREE.Vector3();
    let previewDone = false;
    let xrRef = null, hitSrc = null, hitReq = false;

    // ============================================================
    // -------------------- 초기 프리뷰 ----------------------------
    // ============================================================
    function drawPreview(){
      if (previewDone || !A1 || segs.length===0) return;

      const xrCam = renderer.xr.getCamera(camera);
      const camPos = new THREE.Vector3();
      xrCam.getWorldPosition(camPos);

      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(xrCam.quaternion).normalize();
      const anchorWorld = camPos.clone().add(dir.multiplyScalar(1)); // 1m 앞

      // preview: scale=1, yaw=0, translate so A1 goes to anchorWorld
      gScale=1; gYaw=0;

      const A1_t = A1.clone(); // scale,yaw=1,0 → 그대로
      gTrans = anchorWorld.clone().sub(A1_t);

      redrawPlan();
      previewDone = true;
      setStatus("도면 프리뷰 표시됨");
    }

    // ============================================================
    // ----------------- 도면 변환 후 그리기 -----------------------
    // ============================================================
    function planToWorld(x_mm, y_mm){
      const p = new THREE.Vector3(x_mm*MM, 0, y_mm*MM);  // DXF(y)→Z(양수)

      p.multiplyScalar(gScale);
      p.applyAxisAngle(new THREE.Vector3(0,1,0), gYaw);
      p.add(gTrans);

      return p;
    }

    function redrawPlan(){
      planGroup.clear();
      const mat = new THREE.LineBasicMaterial({ color:0x00ffff });

      for (const s of segs){
        const p1 = planToWorld(s.x1, s.y1);
        const p2 = planToWorld(s.x2, s.y2);
        const geom = new THREE.BufferGeometry().setFromPoints([p1,p2]);
        planGroup.add(new THREE.Line(geom, mat));
      }
    }

    // ============================================================
    // ----------------------- 정합 계산 ---------------------------
    // ============================================================
    function computeAlignment(){
      // A1–A2 (도면 기준선)
      const vp = new THREE.Vector2(A2.x - A1.x, A2.z - A1.z);
      const lenP = vp.length();

      // B1–B2 (현실 기준선)
      const vw = new THREE.Vector2(B2.x - B1.x, B2.z - B1.z);
      const lenW = vw.length();

      gScale = lenW / lenP;

      const angP = Math.atan2(vp.y, vp.x);
      const angW = Math.atan2(vw.y, vw.x);
      gYaw = angW - angP;

      let A_anchor, B_anchor;
      if (first==="B1"){ A_anchor=A1; B_anchor=B1; }
      else { A_anchor=A2; B_anchor=B2; }

      const A_t = A_anchor.clone().multiplyScalar(gScale);
      A_t.applyAxisAngle(new THREE.Vector3(0,1,0), gYaw);

      gTrans = B_anchor.clone().sub(A_t);

      redrawPlan();

      setResult(
        `Anchor: ${first}\n` +
        `도면길이 = ${lenP.toFixed(3)} m\n` +
        `현실길이 = ${lenW.toFixed(3)} m\n` +
        `scale = ${gScale.toFixed(5)}\n` +
        `yaw = ${(gYaw*180/Math.PI).toFixed(3)}°`
      );
      setStatus("정합 완료");
    }

    // ============================================================
    // --------------------- 사용자 선택 ---------------------------
    // ============================================================
    function selectPointAtReticle(){
      if (!reticle.visible){
        setStatus("hit-test 없음");
        return;
      }

      const pos = reticle.position.clone();
      const sel = selectPoint.value;

      if (!first) first = sel;

      if (sel==="B1") B1 = pos;
      else            B2 = pos;

      setStatus(`${sel} 저장 완료`);

      if (B1 && B2){
        computeAlignment();
      }
    }

    // ============================================================
    // --------------------- AR 세션 시작 ---------------------------
    // ============================================================
    function startAR(){
      const init = {
        requiredFeatures:["hit-test"],
        optionalFeatures:["dom-overlay"],
        domOverlay:{ root:document.body }
      };

      navigator.xr.requestSession("immersive-ar", init).then((session)=>{
        renderer.xr.setSession(session);
        session.requestReferenceSpace("local").then(ref=>xrRef=ref);

        session.addEventListener("end", ()=>{
          B1=B2=first=null;
          previewDone=false;
          planGroup.clear();
          selectPoint.disabled=true;
          btnMain.textContent="START AR";
          setStatus("AR 종료");
        });

        selectPoint.disabled=false;
        btnMain.textContent="선택";
        setStatus("AR 시작됨. B1/B2 선택");

      }).catch(()=>setStatus("AR 불가"));
    }

    btnMain.onclick = ()=>{
      if (btnMain.textContent==="START AR") startAR();
      else selectPointAtReticle();
    };

    // ============================================================
    // --------------------- 렌더 루프 -----------------------------
    // ============================================================
    renderer.setAnimationLoop((time, frame)=>{
      const session = renderer.xr.getSession();
      if (!session || !frame){ renderer.render(scene, camera); return; }

      if (!hitReq){
        session.requestReferenceSpace("viewer").then(viewerSpace=>{
          session.requestHitTestSource({ space:viewerSpace })
            .then(src=>hitSrc=src);
        });
        hitReq=true;
      }

      if (hitSrc && xrRef){
        const hits = frame.getHitTestResults(hitSrc);
        if (hits.length>0){
          const pose = hits[0].getPose(xrRef);
          if (pose){
            const m = new THREE.Matrix4().fromArray(pose.transform.matrix);
            reticle.visible=true;
            reticle.position.setFromMatrixPosition(m);

            // 초기 프리뷰는 hit-test가 있어야 정확
            drawPreview();
          }
        } else reticle.visible=false;
      }

      renderer.render(scene, camera);
    });

    window.onresize = ()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };
  </script>
</body>
</html>
