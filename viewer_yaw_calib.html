<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>AR Yaw Calib (A1/A2 – B1/B2)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      color: #fff;
    }

    #overlay-ui {
      position: fixed;
      inset: 0;
      pointer-events: none;
    }

    #top-bar {
      position: absolute;
      top: env(safe-area-inset-top, 8px);
      left: 0;
      right: 0;
      text-align: center;
      font-size: 14px;
      text-shadow: 0 0 4px rgba(0,0,0,0.7);
      pointer-events: none;
    }

    #center-dot {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(255,255,255,0.95);
      pointer-events: none;
    }

    #bottom-bar {
      position: absolute;
      bottom: env(safe-area-inset-bottom, 12px);
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      pointer-events: auto;
    }

    #instruction {
      font-size: 11px;
      text-align: center;
      max-width: 90vw;
      opacity: 0.9;
    }

    #controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    select {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.4);
      background: rgba(0,0,0,0.4);
      color: #fff;
      font-size: 12px;
    }

    button {
      min-width: 120px;
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      font-size: 13px;
      font-weight: 600;
      color: #fff;
      background: #007aff;
      box-shadow: 0 4px 10px rgba(0,0,0,0.4);
    }

    button:disabled {
      opacity: 0.5;
      box-shadow: none;
    }

    #status-label {
      font-size: 11px;
      opacity: 0.9;
      text-align: center;
    }

    #result-label {
      font-size: 11px;
      opacity: 0.9;
      text-align: center;
      max-width: 95vw;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <div id="overlay-ui">
    <div id="top-bar">A1/A2 ↔ B1/B2 Yaw 보정 테스트</div>
    <div id="center-dot"></div>

    <div id="bottom-bar">
      <div id="instruction">
        처음에는 [START AR]를 눌러 AR을 시작합니다.<br/>
        AR 시작 후에는 왼쪽에서 B1/B2를 고르고 [선택]으로 찍으세요.
      </div>

      <div id="controls">
        <select id="point-select" disabled>
          <option value="B1">B1</option>
          <option value="B2">B2</option>
        </select>
        <button id="main-button">START AR</button>
      </div>

      <div id="status-label">상태: 준비 완료</div>
      <div id="result-label"></div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js";

    // ---------- 기본 three.js / WebXR ----------
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      70, window.innerWidth / window.innerHeight, 0.01, 50
    );

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
    scene.add(light);

    // 바닥 hit-test용 3D 원 레티클
    const reticle3D = new THREE.Mesh(
      new THREE.RingGeometry(0.03, 0.035, 32),
      new THREE.MeshBasicMaterial({ color: 0xffffff })
    );
    reticle3D.rotation.x = -Math.PI / 2;
    reticle3D.visible = false;
    scene.add(reticle3D);

    // ---------- 도면/측정 단위 ----------
    const MM_TO_M = 0.001;  // 도면은 mm, WebXR은 m

    // A1/A2 (도면상의 기준점) – m 단위로 저장
    let A1_PLAN_M = null; // THREE.Vector2
    let A2_PLAN_M = null;

    // 도면 선들 (Office_2.json에서 읽음)
    const planSegments = []; // {x1,y1,x2,y2} in mm
    const planGroup = new THREE.Group();
    scene.add(planGroup);

    async function loadPlanJson() {
      try {
        const res = await fetch("./Office_2.json");
        const json = await res.json();

        const layersObj = json.layers && typeof json.layers === "object"
          ? json.layers
          : json;

        // A1/A2 먼저 추출
        if (layersObj.A1 && layersObj.A1[0] && layersObj.A1[0].center) {
          const [x, y] = layersObj.A1[0].center;
          A1_PLAN_M = new THREE.Vector2(x * MM_TO_M, y * MM_TO_M);
        }
        if (layersObj.A2 && layersObj.A2[0] && layersObj.A2[0].center) {
          const [x, y] = layersObj.A2[0].center;
          A2_PLAN_M = new THREE.Vector2(x * MM_TO_M, y * MM_TO_M);
        }

        // LINE / LWPOLYLINE 추출
        for (const [layerName, ents] of Object.entries(layersObj)) {
          if (!Array.isArray(ents)) continue;
          if (layerName === "A1" || layerName === "A2") continue;

          for (const ent of ents) {
            if (ent.type === "LINE" && Array.isArray(ent.start) && Array.isArray(ent.end)) {
              const [x1, y1] = ent.start;
              const [x2, y2] = ent.end;
              planSegments.push({ x1, y1, x2, y2 });
            } else if (ent.type === "LWPOLYLINE" && Array.isArray(ent.points)) {
              for (let i = 0; i < ent.points.length - 1; i++) {
                const [x1, y1] = ent.points[i];
                const [x2, y2] = ent.points[i + 1];
                planSegments.push({ x1, y1, x2, y2 });
              }
            }
          }
        }

        if (!A1_PLAN_M || !A2_PLAN_M) {
          setStatus("A1/A2 기준점을 JSON에서 찾지 못했습니다.");
        } else {
          console.log("A1(m):", A1_PLAN_M, "A2(m):", A2_PLAN_M);
          setStatus("도면 JSON 로드 완료. AR에서 B1/B2를 찍어 보정하세요.");
        }
      } catch (e) {
        console.error(e);
        setStatus("Office_2.json 로드 실패");
      }
    }

    loadPlanJson();

    // ---------- AR / Hit-test 상태 ----------
    let xrSession = null;
    let xrRefSpace = null;
    let hitTestSource = null;
    let hitTestSourceRequested = false;

    let B1_world = null;
    let B2_world = null;

    // 첫 번째로 선택된 현실 점(B1/B2)이 무엇인지 → 그에 대응하는 A1/A2가 anchor
    let firstSelectedLabel = null; // "B1" or "B2"

    // 최종 변환값 (도면 → 월드)
    let gScale = 1.0;          // 도면 스케일 (m 단위에서)
    let gYaw = 0.0;            // yaw (라디안)
    let gTrans = new THREE.Vector3(); // 평행이동 T

    const pointSelect = document.getElementById("point-select");
    const mainButton = document.getElementById("main-button");
    const statusLabel = document.getElementById("status-label");
    const resultLabel = document.getElementById("result-label");

    function setStatus(msg) {
      statusLabel.textContent = "상태: " + msg;
      console.log("[STATUS]", msg);
    }

    function setResult(msg) {
      resultLabel.textContent = msg;
      console.log("[RESULT]\n" + msg);
    }

    let isARStarted = false;

    mainButton.addEventListener("click", () => {
      if (!isARStarted) {
        startAR();
      } else {
        selectCurrentPoint();
      }
    });

    function startAR() {
      if (!navigator.xr) {
        setStatus("이 브라우저는 WebXR(AR)을 지원하지 않습니다.");
        return;
      }

      const sessionInit = {
        requiredFeatures: ["hit-test"],
        optionalFeatures: ["dom-overlay"],
        domOverlay: { root: document.body }
      };

      navigator.xr.requestSession("immersive-ar", sessionInit)
        .then((session) => {
          xrSession = session;
          renderer.xr.setReferenceSpaceType("local");
          renderer.xr.setSession(session);

          session.addEventListener("end", () => {
            xrSession = null;
            xrRefSpace = null;
            hitTestSource = null;
            hitTestSourceRequested = false;
            reticle3D.visible = false;
            isARStarted = false;
            mainButton.textContent = "START AR";
            pointSelect.disabled = true;
            B1_world = null;
            B2_world = null;
            firstSelectedLabel = null;
            planGroup.clear();
            setStatus("AR 세션 종료");
          });

          session.requestReferenceSpace("local").then((refSpace) => {
            xrRefSpace = refSpace;
          });

          isARStarted = true;
          mainButton.textContent = "선택";
          pointSelect.disabled = false;
          setStatus("바닥에 레티클을 맞춘 뒤, B1/B2를 선택해서 찍으세요.");
        })
        .catch((err) => {
          console.error(err);
          setStatus("AR 세션 시작 실패");
        });
    }

    function selectCurrentPoint() {
      if (!reticle3D.visible) {
        setStatus("바닥 hit-test가 아직 없습니다. 카메라를 바닥으로 향하게 해 보세요.");
        return;
      }

      const pos = reticle3D.position.clone();
      const label = pointSelect.value; // "B1" or "B2"

      if (!firstSelectedLabel) {
        firstSelectedLabel = label; // 처음 선택한 현실 점
        setStatus(`첫 기준점으로 ${label}를 선택했습니다.`);
      }

      if (label === "B1") {
        B1_world = pos;
        setStatus(`B1 저장: (${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)})`);
      } else {
        B2_world = pos;
        setStatus(`B2 저장: (${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)})`);
      }

      if (B1_world && B2_world && A1_PLAN_M && A2_PLAN_M) {
        computeTransformAndRedraw();
      }
    }

    // ---------- 도면 좌표(mm) → 월드 좌표 변환 ----------
    function planToWorld(x_mm, y_mm) {
      // 도면 mm → m (2D)
      const p = new THREE.Vector3(
        x_mm * MM_TO_M, // X
        0,
        y_mm * MM_TO_M  // Z (도면 Y를 Z로 사용)
      );

      // scale 적용
      p.multiplyScalar(gScale);

      // yaw 회전 (Y축)
      const rotY = new THREE.Matrix4().makeRotationY(gYaw);
      p.applyMatrix4(rotY);

      // 평행이동
      p.add(gTrans);

      return p;
    }

    // ---------- 변환 계산: scale + yaw + translation ----------
    function computeTransformAndRedraw() {
      // 1) 도면 A1–A2 길이 (m 단위)
      const vPlan = new THREE.Vector2(
        A2_PLAN_M.x - A1_PLAN_M.x,
        A2_PLAN_M.y - A1_PLAN_M.y
      );
      const lenPlan = vPlan.length();      // m

      // 2) 현실 B1–B2 길이 (m, XZ 평면)
      const vWorld2D = new THREE.Vector2(
        B2_world.x - B1_world.x,
        B2_world.z - B1_world.z
      );
      const lenWorld = vWorld2D.length();  // m

      if (lenPlan === 0 || lenWorld === 0) {
        setResult("벡터 길이가 0이라 보정할 수 없습니다.");
        return;
      }

      // 3) 도면을 현실 길이에 맞추는 스케일
      gScale = lenWorld / lenPlan;   // (현실) / (도면)

      // 4) yaw (수평 방향만)
      const anglePlan = Math.atan2(vPlan.y, vPlan.x);
      const angleWorld = Math.atan2(vWorld2D.y, vWorld2D.x);
      gYaw = angleWorld - anglePlan;

      // 5) anchor(A1 또는 A2) ↔ 처음 선택된 B1/B2 로 평행이동 계산
      let anchorPlan2D;   // THREE.Vector2 (m)
      let anchorWorld3D;  // THREE.Vector3 (m)

      if (firstSelectedLabel === "B1") {
        anchorPlan2D = A1_PLAN_M;          // A1 ↔ B1
        anchorWorld3D = B1_world;
      } else {
        anchorPlan2D = A2_PLAN_M;          // A2 ↔ B2
        anchorWorld3D = B2_world;
      }

      const anchorPlan3D = new THREE.Vector3(
        anchorPlan2D.x,
        0,
        anchorPlan2D.y
      );
      anchorPlan3D.multiplyScalar(gScale);
      const rotY = new THREE.Matrix4().makeRotationY(gYaw);
      anchorPlan3D.applyMatrix4(rotY);

      // T = B_anchor - R * s * A_anchor
      gTrans = anchorWorld3D.clone().sub(anchorPlan3D);

      const yawDeg = gYaw * 180 / Math.PI;
      const msg =
        `첫 기준점: ${firstSelectedLabel} (=> ${firstSelectedLabel === "B1" ? "A1" : "A2"})\n\n` +
        `A1(m) = (${A1_PLAN_M.x.toFixed(3)}, ${A1_PLAN_M.y.toFixed(3)})\n` +
        `A2(m) = (${A2_PLAN_M.x.toFixed(3)}, ${A2_PLAN_M.y.toFixed(3)})\n` +
        `도면 A1–A2 길이 = ${lenPlan.toFixed(3)} m\n\n` +
        `B1 = (${B1_world.x.toFixed(3)}, ${B1_world.y.toFixed(3)}, ${B1_world.z.toFixed(3)}) m\n` +
        `B2 = (${B2_world.x.toFixed(3)}, ${B2_world.y.toFixed(3)}, ${B2_world.z.toFixed(3)}) m\n` +
        `실세계 B1–B2 길이 = ${lenWorld.toFixed(3)} m\n\n` +
        `스케일(scale 도면→현실) = ${gScale.toFixed(5)}\n` +
        `Yaw(rad) = ${gYaw.toFixed(5)}\n` +
        `Yaw(°)   = ${yawDeg.toFixed(3)}°`;

      setResult(msg);
      setStatus("보정 완료. 도면을 anchor 기준으로 다시 그립니다.");

      // 6) 도면 전체를 다시 그림
      planGroup.clear();
      const mat = new THREE.LineBasicMaterial({ color: 0x00ffff });

      for (const seg of planSegments) {
        const p1 = planToWorld(seg.x1, seg.y1);
        const p2 = planToWorld(seg.x2, seg.y2);
        const geom = new THREE.BufferGeometry().setFromPoints([p1, p2]);
        const line = new THREE.Line(geom, mat);
        planGroup.add(line);
      }
    }

    // ---------- 렌더 루프 / hit-test ----------
    renderer.setAnimationLoop((time, frame) => {
      const session = renderer.xr.getSession();
      if (!session || !frame) {
        renderer.render(scene, camera);
        return;
      }

      if (!xrRefSpace) {
        // referenceSpace 는 startAR 시에 요청하지만,
        // 혹시 null 이면 한 번 더 시도
        session.requestReferenceSpace("local").then((refSpace) => {
          xrRefSpace = refSpace;
        });
      }

      if (!hitTestSourceRequested) {
        session.requestReferenceSpace("viewer").then((viewerSpace) => {
          session.requestHitTestSource({ space: viewerSpace })
            .then((source) => {
              hitTestSource = source;
            })
            .catch((err) => console.error("HitTestSource 오류:", err));
        });
        hitTestSourceRequested = true;
      }

      if (hitTestSource && xrRefSpace) {
        const hits = frame.getHitTestResults(hitTestSource);
        if (hits.length > 0) {
          const hit = hits[0];
          const pose = hit.getPose(xrRefSpace);
          if (pose) {
            const mat = new THREE.Matrix4().fromArray(pose.transform.matrix);
            reticle3D.visible = true;
            reticle3D.position.setFromMatrixPosition(mat);
          }
        } else {
          reticle3D.visible = false;
        }
      }

      renderer.render(scene, camera);
    });

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
