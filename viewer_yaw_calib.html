<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>AR A1–A2 ↔ B1–B2 정합 테스트</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      color: #fff;
    }
    #overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
    }
    #top-bar {
      position: absolute;
      top: env(safe-area-inset-top, 8px);
      left: 0;
      right: 0;
      text-align: center;
      font-size: 14px;
      text-shadow: 0 0 4px rgba(0,0,0,0.7);
    }
    #center-dot {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #fff;
    }
    #bottom-bar {
      position: absolute;
      bottom: env(safe-area-inset-bottom, 16px);
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: center;
      pointer-events: auto;
    }
    #instruction {
      font-size: 11px;
      text-align: center;
      max-width: 90vw;
      opacity: 0.9;
    }
    #controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    select {
      padding: 8px 10px;
      border-radius: 999px;
      border: none;
      background: #007aff;
      color: #fff;
      font-size: 13px;
    }
    button {
      padding: 8px 16px;
      border-radius: 999px;
      border: none;
      background: #007aff;
      color: #fff;
      font-size: 13px;
      font-weight: 600;
    }
    #status, #result {
      font-size: 11px;
      text-align: center;
      white-space: pre-line;
      max-width: 95vw;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="top-bar">A1–A2 ↔ B1–B2 정합 테스트</div>
    <div id="center-dot"></div>
    <div id="bottom-bar">
      <div id="instruction">
        1) START AR를 눌러 AR을 시작합니다.<br/>
        2) B1/B2를 선택해서 바닥 위 점을 찍습니다.<br/>
        3) 두 점을 모두 찍으면 도면이 정합됩니다.
      </div>
      <div id="controls">
        <select id="point-select" disabled>
          <option value="B1">B1</option>
          <option value="B2">B2</option>
        </select>
        <button id="btn-main">START AR</button>
      </div>
      <div id="status">상태: 준비</div>
      <div id="result"></div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js";

    // ===================== 기본 세팅 ===========================
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 50);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
    scene.add(light);

    // 바닥 hit-test용 3D 레티클(원)
    const reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.03, 0.035, 32),
      new THREE.MeshBasicMaterial({ color: 0xffffff })
    );
    reticle.rotation.x = -Math.PI / 2;
    reticle.visible = false;
    scene.add(reticle);

    // ===================== UI 요소 ============================
    const pointSelect = document.getElementById("point-select");
    const btnMain     = document.getElementById("btn-main");
    const statusBox   = document.getElementById("status");
    const resultBox   = document.getElementById("result");

    function setStatus(msg) { statusBox.textContent = "상태: " + msg; }
    function setResult(msg) { resultBox.textContent = msg; }

    // ===================== 도면 데이터 =========================
    const MM_TO_M = 0.001;
    let A1 = null; // THREE.Vector3 (m)  DXF: (x, y) → (x, 0, -y)
    let A2 = null;
    const planSegments = []; // {x1,y1,x2,y2,layer}
    const planGroup = new THREE.Group();
    scene.add(planGroup);

    async function loadPlanJson() {
      try {
        const res = await fetch("./Office_2.json");
        const json = await res.json();
        const layers = json.layers && typeof json.layers === "object" ? json.layers : json;

        // A1/A2 중심점 읽기 (z = -y 로 통일)
        if (layers.A1 && layers.A1[0] && layers.A1[0].center) {
          const [x_mm, y_mm] = layers.A1[0].center;
          A1 = new THREE.Vector3(x_mm * MM_TO_M, 0, -y_mm * MM_TO_M);
        }
        if (layers.A2 && layers.A2[0] && layers.A2[0].center) {
          const [x_mm, y_mm] = layers.A2[0].center;
          A2 = new THREE.Vector3(x_mm * MM_TO_M, 0, -y_mm * MM_TO_M);
        }

        for (const [layerName, ents] of Object.entries(layers)) {
          if (!Array.isArray(ents)) continue;
          if (layerName === "A1" || layerName === "A2") continue;

          for (const ent of ents) {
            if (ent.type === "LINE" && Array.isArray(ent.start) && Array.isArray(ent.end)) {
              const [x1, y1] = ent.start;
              const [x2, y2] = ent.end;
              planSegments.push({ x1, y1, x2, y2, layer: layerName });
            } else if (ent.type === "LWPOLYLINE" && Array.isArray(ent.points)) {
              for (let i = 0; i < ent.points.length - 1; i++) {
                const [x1, y1] = ent.points[i];
                const [x2, y2] = ent.points[i + 1];
                planSegments.push({ x1, y1, x2, y2, layer: layerName });
              }
            }
          }
        }

        if (!A1 || !A2) {
          setStatus("A1/A2 기준점을 JSON에서 찾지 못했습니다.");
        } else {
          setStatus("도면 로드 완료. START AR를 눌러 주세요.");
        }
      } catch (e) {
        console.error(e);
        setStatus("Office_2.json 로드 실패");
      }
    }
    loadPlanJson();

    // ===================== 정합 상태 ==========================
    let xrSession = null;
    let xrRefSpace = null;
    let hitTestSource = null;
    let hitRequested = false;

    let B1 = null;
    let B2 = null;
    let firstSelected = null; // "B1" or "B2"

    let gScale = 1.0;
    let gYaw   = 0.0;
    let gTrans = new THREE.Vector3();

    function planToWorld(x_mm, y_mm) {
      // DXF (x, y_mm) → 3D (x_m, 0, -y_m), 이후 scale/회전/이동
      const p = new THREE.Vector3(x_mm * MM_TO_M, 0, -y_mm * MM_TO_M);
      p.multiplyScalar(gScale);
      p.applyAxisAngle(new THREE.Vector3(0, 1, 0), gYaw);
      p.add(gTrans);
      return p;
    }

    function redrawPlan() {
      planGroup.clear();
      const mat = new THREE.LineBasicMaterial({ color: 0x00ffff });
      for (const seg of planSegments) {
        const p1 = planToWorld(seg.x1, seg.y1);
        const p2 = planToWorld(seg.x2, seg.y2);
        const geom = new THREE.BufferGeometry().setFromPoints([p1, p2]);
        const line = new THREE.Line(geom, mat);
        line.userData.layer = seg.layer;
        planGroup.add(line);
      }
    }

    function computeAlignment() {
      // 1) 도면 기준선 A1→A2 (XZ 평면, z=-y 사용)
      const vPlan = new THREE.Vector2(A2.x - A1.x, A2.z - A1.z);
      const lenPlan = vPlan.length();

      // 2) 현실 기준선 B1→B2
      const vWorld = new THREE.Vector2(B2.x - B1.x, B2.z - B1.z);
      const lenWorld = vWorld.length();

      if (lenPlan === 0 || lenWorld === 0) {
        setResult("길이가 0이어서 정합 불가");
        return;
      }

      // 3) scale, yaw
      gScale = lenWorld / lenPlan;
      const angPlan  = Math.atan2(vPlan.y,  vPlan.x);
      const angWorld = Math.atan2(vWorld.y, vWorld.x);
      gYaw = angWorld - angPlan;

      // 4) anchor: 첫 번째로 선택된 현실 점 ↔ A1 또는 A2
      let A_anchor, B_anchor;
      if (firstSelected === "B1") {
        A_anchor = A1.clone();
        B_anchor = B1.clone();
      } else {
        A_anchor = A2.clone();
        B_anchor = B2.clone();
      }

      const A_t = A_anchor.clone().multiplyScalar(gScale);
      A_t.applyAxisAngle(new THREE.Vector3(0, 1, 0), gYaw);
      gTrans = B_anchor.clone().sub(A_t);

      redrawPlan();

      const yawDeg = gYaw * 180 / Math.PI;
      const msg =
        `Anchor: ${firstSelected} (→ ${firstSelected === "B1" ? "A1" : "A2"})\n` +
        `도면 A1–A2 길이 = ${lenPlan.toFixed(3)} m\n` +
        `실세계 B1–B2 길이 = ${lenWorld.toFixed(3)} m\n` +
        `scale = ${gScale.toFixed(5)}\n` +
        `yaw = ${yawDeg.toFixed(3)}°`;
      setResult(msg);
      setStatus("정합 완료");
    }

    // ===================== 사용자 입력 =========================
    btnMain.addEventListener("click", () => {
      if (!xrSession) {
        startAR();
      } else {
        selectCurrentPoint();
      }
    });

    function startAR() {
      if (!navigator.xr) {
        setStatus("이 브라우저는 WebXR(AR)을 지원하지 않습니다.");
        return;
      }
      const init = {
        requiredFeatures: ["hit-test"],
        optionalFeatures: ["dom-overlay"],
        domOverlay: { root: document.body }
      };
      navigator.xr.requestSession("immersive-ar", init)
        .then((session) => {
          xrSession = session;
          renderer.xr.setReferenceSpaceType("local");
          renderer.xr.setSession(session);

          session.requestReferenceSpace("local").then((refSpace) => {
            xrRefSpace = refSpace;
          });

          session.addEventListener("end", () => {
            xrSession = null;
            xrRefSpace = null;
            hitTestSource = null;
            hitRequested = false;
            reticle.visible = false;
            planGroup.clear();
            B1 = B2 = null;
            firstSelected = null;
            pointSelect.disabled = true;
            btnMain.textContent = "START AR";
            setStatus("AR 세션 종료");
          });

          pointSelect.disabled = false;
          btnMain.textContent = "선택";
          setStatus("AR 시작됨. B1/B2 선택");
        })
        .catch((err) => {
          console.error(err);
          setStatus("AR 세션 시작 실패");
        });
    }

    function selectCurrentPoint() {
      if (!reticle.visible) {
        setStatus("바닥 hit-test 없음 (카메라를 바닥으로 움직이세요)");
        return;
      }
      const pos = reticle.position.clone();
      const sel = pointSelect.value; // "B1" or "B2"

      if (!firstSelected) firstSelected = sel;

      if (sel === "B1") {
        B1 = pos;
        setStatus(`B1 저장: (${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)})`);
      } else {
        B2 = pos;
        setStatus(`B2 저장: (${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)})`);
      }

      if (B1 && B2 && A1 && A2) {
        computeAlignment();
      }
    }

    // ===================== 렌더 루프 / hit-test =================
    renderer.setAnimationLoop((time, frame) => {
      const session = renderer.xr.getSession();
      if (!session || !frame) {
        renderer.render(scene, camera);
        return;
      }

      if (!hitRequested) {
        session.requestReferenceSpace("viewer").then((viewerSpace) => {
          session.requestHitTestSource({ space: viewerSpace })
            .then((source) => { hitTestSource = source; })
            .catch((err) => console.error("hitTestSource 오류:", err));
        });
        hitRequested = true;
      }

      if (hitTestSource && xrRefSpace) {
        const hits = frame.getHitTestResults(hitTestSource);
        if (hits.length > 0) {
          const hit = hits[0];
          const pose = hit.getPose(xrRefSpace);
          if (pose) {
            const mat = new THREE.Matrix4().fromArray(pose.transform.matrix);
            reticle.visible = true;
            reticle.position.setFromMatrixPosition(mat);
          }
        } else {
          reticle.visible = false;
        }
      }

      renderer.render(scene, camera);
    });

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
