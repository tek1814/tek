<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>AR Plan Yaw Calibration</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    body { margin:0; overflow:hidden; background:#000; color:#fff; font-family:system-ui, sans-serif; }
    #overlay { position:fixed; inset:0; pointer-events:none; }
    #info {
      position:absolute; top:8px; left:50%; transform:translateX(-50%);
      background:rgba(0,0,0,0.6); padding:6px 12px; border-radius:4px;
      font-size:13px; z-index:20; white-space:nowrap;
    }
    #buttons {
      position:absolute; bottom:10px; left:50%; transform:translateX(-50%);
      display:flex; gap:6px; z-index:30; pointer-events:auto;
    }
    #buttons button {
      padding:8px 10px; border-radius:16px; border:none;
      background:rgba(0,122,255,0.9); color:#fff; font-size:12px;
    }
  </style>
</head>
<body>
<div id="overlay">
  <div id="info">START AR를 누르고, 바닥을 인식한 뒤 B1/B2를 찍으세요.</div>
  <div id="buttons">
    <button id="btnB1">B1 선택</button>
    <button id="btnB2">B2 선택</button>
    <button id="btnCalib">정합 실행</button>
  </div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
import { ARButton } from "https://unpkg.com/three@0.161.0/examples/jsm/webxr/ARButton.js";

let camera, scene, renderer;
let referenceSpace = null;
let hitTestSource = null;
let hitTestSourceRequested = false;

const infoEl = document.getElementById("info");
const btnB1 = document.getElementById("btnB1");
const btnB2 = document.getElementById("btnB2");
const btnCalib = document.getElementById("btnCalib");

// ==========================
// 1. 도면 기준점 (mm 단위)
// ==========================
// 여기는 네가 사용하는 도면 JSON에서 실제 B1/B2 좌표(mm)를 넣으면 됨.
const B1_plan_mm = new THREE.Vector2(0, 0);        // 예: (0,0)
const B2_plan_mm = new THREE.Vector2(5000, 0);     // 예: (5000,0) = 5m

// 도면에서 그릴 선분들 (샘플). [ [x1,y1, x2,y2], ... ] mm 단위
const planLines_mm = [
  [-1000, 0, 6000, 0],     // B1-B2 방향 직선
  [0, -2000, 0, 2000],     // B1 기준 수직선
  [5000, -2000, 5000, 2000]// B2 기준 수직선
];

// ==========================
// 2. AR에서의 기준점
// ==========================
let reticle;
let B1_ar = null;
let B2_ar = null;

// 정합 결과 (전역)
let calibScale = 1.0;
let calibRot = new THREE.Quaternion(); // yaw만 포함
let calibTrans = new THREE.Vector3();  // translation

let planGroup = new THREE.Group();     // 도면 전체를 담는 그룹

init();
animate();

function init() {
  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

  const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
  scene.add(light);

  // ===== 3D 레티클 (원 + 가운데 점) =====
  const ring = new THREE.Mesh(
    new THREE.RingGeometry(0.03, 0.035, 48),
    new THREE.MeshBasicMaterial({ color:0xffffff, side:THREE.DoubleSide })
  );
  const dot = new THREE.Mesh(
    new THREE.CircleGeometry(0.006, 32),
    new THREE.MeshBasicMaterial({ color:0xffffff, side:THREE.DoubleSide })
  );
  dot.position.y = 0.001;

  reticle = new THREE.Group();
  reticle.add(ring);
  reticle.add(dot);
  reticle.visible = false;
  scene.add(reticle);

  // ===== 도면 그룹(처음엔 원점에 생성, 나중에 변환) =====
  scene.add(planGroup);

  // AR 버튼
  document.body.appendChild(ARButton.createButton(renderer, {
    requiredFeatures: ['hit-test'],
    optionalFeatures: ['dom-overlay','local-floor'],
    domOverlay: { root: document.getElementById('overlay') }
  }));

  renderer.xr.addEventListener("sessionstart", async () => {
    const session = renderer.xr.getSession();
    referenceSpace = await session.requestReferenceSpace("local-floor");
    hitTestSourceRequested = false;
    hitTestSource = null;
    B1_ar = null;
    B2_ar = null;
    infoEl.textContent = "바닥을 향해 움직여 평면을 먼저 안정화하세요.";
  });

  // 버튼 이벤트
  btnB1.addEventListener("click", onSelectB1);
  btnB2.addEventListener("click", onSelectB2);
  btnCalib.addEventListener("click", onCalibrate);

  window.addEventListener("resize", onWindowResize);
}

// 화면 리사이즈
function onWindowResize() {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// B1 선택
function onSelectB1() {
  if (!reticle.visible) {
    infoEl.textContent = "레티클이 보이는 상태에서 B1을 선택하세요.";
    return;
  }
  const p = new THREE.Vector3();
  reticle.getWorldPosition(p);
  B1_ar = p.clone();
  infoEl.textContent = `B1 선택: (${B1_ar.x.toFixed(2)}, ${B1_ar.z.toFixed(2)})`;
  console.log("B1_ar", B1_ar);
}

// B2 선택
function onSelectB2() {
  if (!reticle.visible) {
    infoEl.textContent = "레티클이 보이는 상태에서 B2를 선택하세요.";
    return;
  }
  const p = new THREE.Vector3();
  reticle.getWorldPosition(p);
  B2_ar = p.clone();
  infoEl.textContent = `B2 선택: (${B2_ar.x.toFixed(2)}, ${B2_ar.z.toFixed(2)})`;
  console.log("B2_ar", B2_ar);
}

// 정합 실행 (전략 1 + yaw-only)
function onCalibrate() {
  if (!B1_ar || !B2_ar) {
    infoEl.textContent = "먼저 B1과 B2를 선택하세요.";
    return;
  }

  // 1) 도면 기준점 (mm→m, z축에 y를 매핑)
  const B1_plan = new THREE.Vector3(B1_plan_mm.x/1000, 0, B1_plan_mm.y/1000);
  const B2_plan = new THREE.Vector3(B2_plan_mm.x/1000, 0, B2_plan_mm.y/1000);

  const d_plan = B1_plan.distanceTo(B2_plan);
  const d_ar = B1_ar.distanceTo(B2_ar);

  calibScale = d_ar / d_plan;

  // 2) yaw만 계산 (XZ 평면에서 회전각)
  const v_plan2 = new THREE.Vector2(
    B2_plan.x - B1_plan.x,
    B2_plan.z - B1_plan.z
  ).normalize();

  const v_ar2 = new THREE.Vector2(
    B2_ar.x - B1_ar.x,
    B2_ar.z - B1_ar.z
  ).normalize();

  const anglePlan = Math.atan2(v_plan2.y, v_plan2.x);
  const angleAr   = Math.atan2(v_ar2.y, v_ar2.x);
  const yaw = angleAr - anglePlan;

  calibRot = new THREE.Quaternion();
  calibRot.setFromAxisAngle(new THREE.Vector3(0,1,0), yaw); // yaw-only

  // 3) 평행이동: B1_ar = R * scale * B1_plan + T
  const temp = B1_plan.clone().multiplyScalar(calibScale).applyQuaternion(calibRot);
  calibTrans = B1_ar.clone().sub(temp);

  infoEl.textContent = "정합 완료. 도면을 AR 공간에 배치합니다.";
  console.log("scale", calibScale);
  console.log("yaw(rad)", yaw);
  console.log("trans", calibTrans);

  // 도면 Mesh 재생성
  rebuildPlanMeshes();
}

// 도면 좌표(mm)를 AR좌표로 변환하는 함수
function planToAR(px_mm, py_mm) {
  const p = new THREE.Vector3(px_mm/1000, 0, py_mm/1000); // 도면에서 (x,y) → (x,0,z)
  p.multiplyScalar(calibScale);
  p.applyQuaternion(calibRot);
  p.add(calibTrans);
  return p;
}

// 도면 선분(planLines_mm)을 메쉬로 만들어서 AR에 배치
function rebuildPlanMeshes() {
  // 기존 것들 제거
  planGroup.clear();

  const mat = new THREE.LineBasicMaterial({ color:0x00ff00 });

  for (const line of planLines_mm) {
    const [x1,y1,x2,y2] = line;
    const p1 = planToAR(x1, y1);
    const p2 = planToAR(x2, y2);

    const geo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
    const seg = new THREE.Line(geo, mat);
    planGroup.add(seg);
  }
}

// AR 렌더링 루프
function animate() {
  renderer.setAnimationLoop(render);
}

function render(timestamp, frame) {
  const session = renderer.xr.getSession();
  if (!session || !frame) {
    renderer.render(scene, camera);
    return;
  }

  // HitTestSource 준비
  if (!hitTestSourceRequested) {
    session.requestReferenceSpace("viewer").then(viewerSpace => {
      session.requestHitTestSource({ space: viewerSpace }).then(source => {
        hitTestSource = source;
      });
    });
    hitTestSourceRequested = true;
  }

  if (hitTestSource && referenceSpace) {
    const hits = frame.getHitTestResults(hitTestSource);
    if (hits.length > 0) {
      const pose = hits[0].getPose(referenceSpace);
      if (pose) {
        reticle.visible = true;
        reticle.matrix.fromArray(pose.transform.matrix);
        reticle.matrix.decompose(reticle.position, reticle.quaternion, reticle.scale);
        infoEl.textContent = "레티클을 기준점 위치에 두고 B1/B2를 찍으세요.";
      }
    } else {
      reticle.visible = false;
      infoEl.textContent = "바닥을 향해 움직여 평면을 먼저 인식하세요.";
    }
  }

  renderer.render(scene, camera);
}
</script>
</body>
</html>
