<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>AR Yaw Calib (A1/A2 – B1/B2)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      color: #fff;
    }

    #overlay-ui {
      position: fixed;
      inset: 0;
      pointer-events: none;
    }

    #top-bar {
      position: absolute;
      top: env(safe-area-inset-top, 8px);
      left: 0;
      right: 0;
      text-align: center;
      font-size: 14px;
      text-shadow: 0 0 4px rgba(0, 0, 0, 0.7);
      pointer-events: none;
    }

    /* 화면 중앙 고정 점 */
    #center-dot {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.95);
      pointer-events: none;
    }

    #bottom-bar {
      position: absolute;
      bottom: env(safe-area-inset-bottom, 12px);
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      pointer-events: auto;
    }

    #instruction {
      font-size: 11px;
      text-align: center;
      max-width: 90vw;
      opacity: 0.9;
    }

    #controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    select {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.4);
      background: rgba(0,0,0,0.4);
      color: #fff;
      font-size: 12px;
    }

    button {
      min-width: 120px;
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      font-size: 13px;
      font-weight: 600;
      color: #fff;
      background: #007aff;
      box-shadow: 0 4px 10px rgba(0,0,0,0.4);
    }

    button:disabled {
      opacity: 0.5;
      box-shadow: none;
    }

    #status-label {
      font-size: 11px;
      opacity: 0.9;
      text-align: center;
    }

    #result-label {
      font-size: 11px;
      opacity: 0.9;
      text-align: center;
      max-width: 95vw;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <div id="overlay-ui">
    <div id="top-bar">A1/A2 ↔ B1/B2 Yaw 보정 테스트</div>
    <div id="center-dot"></div>

    <div id="bottom-bar">
      <div id="instruction">
        처음에는 [START AR]를 눌러 AR을 시작합니다.<br/>
        AR 시작 후에는 왼쪽에서 B1/B2를 고르고 [선택]으로 찍으세요.
      </div>

      <div id="controls">
        <select id="point-select" disabled>
          <option value="B1">B1</option>
          <option value="B2">B2</option>
        </select>
        <button id="main-button">START AR</button>
      </div>

      <div id="status-label">상태: 준비 완료</div>
      <div id="result-label"></div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js";

    // ---------------- 기본 three.js / WebXR 세팅 ----------------
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      70, window.innerWidth / window.innerHeight, 0.01, 50
    );

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
    scene.add(light);

    // 바닥 hit-test용 3D 레티클(원)
    const reticle3D = new THREE.Mesh(
      new THREE.RingGeometry(0.03, 0.035, 32),
      new THREE.MeshBasicMaterial({ color: 0xffffff })
    );
    reticle3D.rotation.x = -Math.PI / 2;
    reticle3D.visible = false;
    scene.add(reticle3D);

    // ---------------- 도면 기준점 A1 / A2 (상수, mm→m) ----------------
    const MM_TO_M = 0.001;

    // Office_2.json 최신 기준: A2(0,0), A1(1500,0)
    const A1_PLAN = new THREE.Vector2(1500 * MM_TO_M, 0 * MM_TO_M); // (1.5m, 0)
    const A2_PLAN = new THREE.Vector2(0 * MM_TO_M,    0 * MM_TO_M); // (0,    0)

    // ---------------- 도면 선 데이터(Office_2.json에서 읽어서 저장) ----------------
    // segments: {x1,y1,x2,y2}  (단위: mm)
    const planSegments = [];
    const planGroup = new THREE.Group();
    scene.add(planGroup);

    async function loadPlanJson() {
      try {
        const res = await fetch("./Office_2.json");
        const json = await res.json();

        // 구조: json.layers 또는 json[레이어명] 들
        const layersObj = json.layers && typeof json.layers === "object"
          ? json.layers
          : json;

        for (const [layerName, ents] of Object.entries(layersObj)) {
          if (!Array.isArray(ents)) continue;
          if (layerName === "A1" || layerName === "A2") continue; // 기준점 레이어는 제외

          for (const ent of ents) {
            if (ent.type === "LINE" && Array.isArray(ent.start) && Array.isArray(ent.end)) {
              const [x1, y1] = ent.start;
              const [x2, y2] = ent.end;
              planSegments.push({ x1, y1, x2, y2 });
            } else if (ent.type === "LWPOLYLINE" && Array.isArray(ent.points)) {
              for (let i = 0; i < ent.points.length - 1; i++) {
                const [x1, y1] = ent.points[i];
                const [x2, y2] = ent.points[i + 1];
                planSegments.push({ x1, y1, x2, y2 });
              }
            }
          }
        }

        console.log("planSegments count:", planSegments.length);
        setStatus("도면 JSON 로드 완료. AR에서 B1/B2를 찍어 보정하세요.");
      } catch (e) {
        console.error(e);
        setStatus("Office_2.json 로드 실패");
      }
    }

    loadPlanJson();

    // ---------------- AR / Hit-test 상태 ----------------
    let xrSession = null;
    let xrRefSpace = null;
    let hitTestSource = null;
    let hitTestSourceRequested = false;

    let B1_world = null;
    let B2_world = null;

    const pointSelect = document.getElementById("point-select");
    const mainButton = document.getElementById("main-button");
    const statusLabel = document.getElementById("status-label");
    const resultLabel = document.getElementById("result-label");

    function setStatus(msg) {
      statusLabel.textContent = "상태: " + msg;
      console.log("[STATUS]", msg);
    }

    function setResult(msg) {
      resultLabel.textContent = msg;
      console.log("[RESULT]\n" + msg);
    }

    let isARStarted = false;
    let gScale = 1.0;
    let gYaw = 0.0;

    mainButton.addEventListener("click", () => {
      if (!isARStarted) {
        startAR();
      } else {
        selectCurrentPoint();
      }
    });

    function startAR() {
      if (!navigator.xr) {
        setStatus("이 브라우저는 WebXR(AR)을 지원하지 않습니다.");
        return;
      }

      const sessionInit = {
        requiredFeatures: ["hit-test"],
        optionalFeatures: ["dom-overlay"],
        domOverlay: { root: document.body }
      };

      navigator.xr.requestSession("immersive-ar", sessionInit)
        .then((session) => {
          xrSession = session;
          renderer.xr.setReferenceSpaceType("local");
          renderer.xr.setSession(session);

          session.addEventListener("end", () => {
            xrSession = null;
            xrRefSpace = null;
            hitTestSource = null;
            hitTestSourceRequested = false;
            reticle3D.visible = false;
            isARStarted = false;
            mainButton.textContent = "START AR";
            pointSelect.disabled = true;
            B1_world = null;
            B2_world = null;
            planGroup.clear();
            setStatus("AR 세션 종료");
          });

          session.requestReferenceSpace("local").then((refSpace) => {
            xrRefSpace = refSpace;
          });

          isARStarted = true;
          mainButton.textContent = "선택";
          pointSelect.disabled = false;
          setStatus("바닥에 레티클이 보이도록 카메라를 움직인 뒤, B1/B2를 선택하세요.");
        })
        .catch((err) => {
          console.error(err);
          setStatus("AR 세션 시작 실패");
        });
    }

    function selectCurrentPoint() {
      if (!reticle3D.visible) {
        setStatus("바닥 hit-test가 아직 없습니다. 카메라를 바닥으로 향하게 해 보세요.");
        return;
      }

      const pos = reticle3D.position.clone();
      const target = pointSelect.value; // "B1" 또는 "B2"

      if (target === "B1") {
        B1_world = pos;
        setStatus(`B1 저장: (${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)})`);
      } else if (target === "B2") {
        B2_world = pos;
        setStatus(`B2 저장: (${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)})`);
      }

      if (B1_world && B2_world) {
        computeYawScaleAndRedraw();
      }
    }

    // ---------------- 도면 좌표 → 월드 좌표 변환 ----------------
    function planToWorld(x_mm, y_mm) {
      // 도면 (mm) → (m) 2D
      const px = x_mm * MM_TO_M;
      const py = y_mm * MM_TO_M;

      // A1 기준 상대좌표
      const relX = px - A1_PLAN.x;
      const relY = py - A1_PLAN.y;

      const cosY = Math.cos(gYaw);
      const sinY = Math.sin(gYaw);

      // yaw 회전 (2D: XZ 평면)
      const rx = relX * cosY - relY * sinY;
      const rz = relX * sinY + relY * cosY;

      // 스케일 적용 + B1 위치로 평행이동
      const worldX = B1_world.x + rx * gScale;
      const worldZ = B1_world.z + rz * gScale;
      const worldY = B1_world.y; // 바닥 높이 그대로

      return new THREE.Vector3(worldX, worldY, worldZ);
    }

    // ---------------- yaw + scale 계산 후 도면 다시 그리기 ----------------
    function computeYawScaleAndRedraw() {
      if (!B1_world || !B2_world) return;
      if (planSegments.length === 0) {
        setStatus("도면 세그먼트가 없습니다(Office_2.json 확인 필요).");
        return;
      }

      // 도면 A1→A2 (2D)
      const vPlan = new THREE.Vector2(
        A2_PLAN.x - A1_PLAN.x,
        A2_PLAN.y - A1_PLAN.y
      );
      const lenPlan = vPlan.length();

      // 월드 B1→B2 (수평면 XZ 투영)
      const vWorld2D = new THREE.Vector2(
        B2_world.x - B1_world.x,
        B2_world.z - B1_world.z
      );
      const lenWorld = vWorld2D.length();

      if (lenPlan === 0 || lenWorld === 0) {
        setResult("벡터 길이가 0이라 보정할 수 없습니다.");
        return;
      }

      gScale = lenWorld / lenPlan;

      const anglePlan = Math.atan2(vPlan.y, vPlan.x);
      const angleWorld = Math.atan2(vWorld2D.y, vWorld2D.x);
      gYaw = angleWorld - anglePlan; // yaw(rad)

      const yawDeg = gYaw * 180 / Math.PI;

      const msg =
        `A1 = (${A1_PLAN.x.toFixed(3)}, ${A1_PLAN.y.toFixed(3)}) m\n` +
        `A2 = (${A2_PLAN.x.toFixed(3)}, ${A2_PLAN.y.toFixed(3)}) m\n` +
        `도면 A1–A2 길이 = ${lenPlan.toFixed(3)} m\n\n` +
        `B1 = (${B1_world.x.toFixed(3)}, ${B1_world.y.toFixed(3)}, ${B1_world.z.toFixed(3)}) m\n` +
        `B2 = (${B2_world.x.toFixed(3)}, ${B2_world.y.toFixed(3)}, ${B2_world.z.toFixed(3)}) m\n` +
        `실세계 B1–B2 길이 = ${lenWorld.toFixed(3)} m\n\n` +
        `스케일(scale) = ${gScale.toFixed(5)}\n` +
        `Yaw(라디안) = ${gYaw.toFixed(5)}\n` +
        `Yaw(도) = ${yawDeg.toFixed(3)}°`;

      setResult(msg);
      setStatus("보정 완료. 도면을 바닥 위에 다시 그립니다.");

      // 도면 다시 그리기
      planGroup.clear();
      const mat = new THREE.LineBasicMaterial({ color: 0x00ffff });

      for (const seg of planSegments) {
        const p1 = planToWorld(seg.x1, seg.y1);
        const p2 = planToWorld(seg.x2, seg.y2);
        const geom = new THREE.BufferGeometry().setFromPoints([p1, p2]);
        const line = new THREE.Line(geom, mat);
        planGroup.add(line);
      }
    }

    // ---------------- 렌더 루프 / hit-test ----------------
    renderer.setAnimationLoop((time, frame) => {
      const session = renderer.xr.getSession();
      if (!session || !frame) {
        renderer.render(scene, camera);
        return;
      }

      if (!xrRefSpace) {
        // session.start 후 한 번만 referenceSpace와 hitTestSource 요청
        if (!hitTestSourceRequested) {
          session.requestReferenceSpace("local").then((refSpace) => {
            xrRefSpace = refSpace;
          });

          session.requestReferenceSpace("viewer").then((viewerSpace) => {
            session.requestHitTestSource({ space: viewerSpace })
              .then((source) => {
                hitTestSource = source;
              })
              .catch((err) => console.error("HitTestSource 오류:", err));
          });

          hitTestSourceRequested = true;
        }
        renderer.render(scene, camera);
        return;
      }

      if (hitTestSource) {
        const hits = frame.getHitTestResults(hitTestSource);
        if (hits.length > 0) {
          const hit = hits[0];
          const pose = hit.getPose(xrRefSpace);
          if (pose) {
            const mat = new THREE.Matrix4().fromArray(pose.transform.matrix);
            reticle3D.visible = true;
            reticle3D.position.setFromMatrixPosition(mat);
          }
        } else {
          reticle3D.visible = false;
        }
      }

      renderer.render(scene, camera);
    });

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
